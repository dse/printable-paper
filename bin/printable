#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

# on Cygwin:
#     apt-cyg install libpaper1 libpaper-bin
# to list all paper sizes and their widths and heights:
#     paperconf -a -n -s
# to get the default paper size:
#     paperconf

our $opt_papersize;
our $opt_width;
our $opt_height;

use Getopt::Long;
use Data::Dumper;
use Carp::Always;

Getopt::Long::Configure(qw(bundling gnu_compat));
Getopt::Long::GetOptions(
    "M|p|media|paper|paper-size=s" => \$opt_papersize,
    "w|width=s"                    => \$opt_width,
    "h|height=s"                   => \$opt_height,
    "h|help" => sub {
        usage();
        exit(0);
    }
) or die("Type '$0 --help' for help.\n");

my $p = My::Printable->new();
$p->set_papersize($opt_papersize) if defined $opt_papersize;
$p->set_width($opt_width)         if defined $opt_width;
$p->set_height($opt_height)       if defined $opt_height;

if (!scalar @ARGV) {
    @ARGV = ("line-dot-grid-paper");
}

foreach my $arg (@ARGV) {
    if ($arg eq "line-dot-grid-paper") {
        $p->generate_line_dot_grid_paper;
    } elsif ($arg eq "line-dot-grid-paper-odd") {
        $p->generate_line_dot_grid_paper;
    } elsif ($arg eq "line-dot-grid-paper-even") {
        $p->generate_line_dot_grid_paper(even => 1);
    }
}

package My::Printable {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;
    INIT {
        public papersize, default => "letter";
        public width,     default => 612;
        public height,    default => 792;
        public doc;
    }

    use XML::LibXML;
    use List::Util qw(min);

    # use My::Printable::Util qw(exclude);
    INIT {
        import My::Printable::Util qw(exclude);
    }

    our $units;
    BEGIN {
        $units = {
            "pt" => {
                to_pt => 1,
                type => "imperial",
            },
            "in" => {
                to_pt => 72,    # 1 in = 72 pt
                type => "imperial",
            },
            "cm" => {
                to_pt => (72 / 2.54), # 1 cm ~= 28.3465 pt
                type => "metric",
            },
            "mm" => {
                to_pt => (72 / 25.4), # 1 cm ~= 2.83465 pt
                type => "metric",
            },
            "px" => {
                to_pt => (72 / 96), # 1 px = 0.75 pt
                type => "imperial"
            },
            "pd" => {
                to_pt => (72 / 300), # 1pd = 1 dot on a 300dpi laser printer = 1/300 in
                type => "imperial"
            }
        };
    }

    our $rx_units;
    our $rx_number;
    BEGIN {
        $rx_units = qr{in|px|pt|cm|mm|pd}ix;
        $rx_number = qr{\d+(?:\.\d*)?|\.\d+}ix;
    }

    sub set_papersize {
        my ($self, $spec) = @_;
        my ($papersize, $width, $height) = $self->read_papersize($spec);
        $self->papersize($papersize);
        $self->width($width);
        $self->height($height);
    }

    sub set_width {
        my ($self, $width) = @_;
        my $result = $self->convert_to_pt($width);
        $self->width($result);
        $self->papersize(undef);
    }

    sub set_height {
        my ($self, $height) = @_;
        my $result = $self->convert_to_pt($height);
        $self->height($result);
        $self->papersize(undef);
    }

    sub convert_to_pt {
        my ($self, $value) = @_;
        if ($value =~ m{\A
                        \s*
                        ($rx_number)
                        (?:
                            \s*
                            /
                            \s*
                            ($rx_number)
                        )?
                        \s*
                        ($rx_units)?
                        \s*
                        \z}xi) {
            my ($number, $denominator, $unit) = ($1, $2, $3);
            if (defined $denominator) {
                $number /= $denominator;
            }
            if (!defined $unit || $unit eq "") {
                return $number;
            }
            return $number * $units->{$unit}->{to_pt};
        } else {
            die("Invalid size specification: $value\n");
        }
    }

    sub parse_custom_papersize {
        my ($self, $papersize) = @_;
        if (defined $papersize && $papersize =~ m{\A
                                                  ($rx_number)
                                                  (?:
                                                      \s*
                                                      /
                                                      \s*
                                                      ($rx_number)
                                                  )?
                                                  \s*
                                                  ($rx_units)?
                                                  \s*
                                                  (?:\*|x)
                                                  \s*
                                                  ($rx_number)
                                                  (?:
                                                      \s*
                                                      /
                                                      \s*
                                                      ($rx_number)
                                                  )?
                                                  \s*
                                                  ($rx_units)?
                                                  \z}xi) {
            my ($width, $width_denominator, $x_unit,
                $height, $height_denominator, $y_unit) = ($1, $2, $3, $4, $5, $6);
            $width /= $width_denominator if defined $width_denominator;
            $height /= $height_denominator if defined $height_denominator;
            if (!defined $y_unit || $y_unit eq "") {
                $y_unit = "pt";
            }
            if (!defined $x_unit || $x_unit eq "") {
                $x_unit = $y_unit;
            }
            $width *= $units->{$x_unit}->{to_pt};
            $height *= $units->{$y_unit}->{to_pt};
            if (wantarray) {
                return (undef, $width, $height);
            }
            return {
                width => $width,
                height => $height
            };
        }
        return;
    }

    sub get_papersize {
        my ($self, $papersize) = @_;
        my $ph;
        my @cmd;
        if (defined $papersize) {
            @cmd = ("paperconf", "-p", $papersize, "-n", "-s");
        } else {
            @cmd = ("paperconf", "-n", "-s");
        }
        if (!open($ph, "-|", @cmd)) {
            die("exec paperconf: $!");
        }
        local $/ = undef;
        my $result = <$ph>;
        if (!close($ph)) {
            die("paperconf failed: $!");
        }
        $result =~ s{\A\s+}{};
        $result =~ s{\s+\z}{};
        my ($papersizename, $width, $height) = split(' ', $result);
        if (wantarray) {
            return ($papersizename, $width, $height);
        }
        return {
            papersize => $papersizename,
            width => $width,
            height => $height
        };
    }

    sub read_papersize {
        my ($self, $papersize) = @_;
        my ($x, $y) = $self->parse_custom_papersize($papersize);
        if (defined $x && defined $y) {
            if (wantarray) {
                return (undef, $x, $y);
            }
            return {
                width => $x,
                height => $y
            };
        }
        return $self->get_papersize($papersize);
    }

    sub generate_line_dot_grid_paper {
        my ($self, %args) = @_;

        my $width = $self->width;
        my $height = $self->height;

        my $left_margin = 0;
        my $right_margin = $width;

        my $bottom_margin = 0;
        my $top_margin = $height;

        my $x_origin = $width / 2;
        my $y_origin = $height / 2;

        my $x_spacing = $self->convert_to_pt("5/16in");
        my $y_spacing = $self->convert_to_pt("5/16in");

        my $left_margin_line = $self->convert_to_pt("1.25in");

        my $line_stroke_width      = $self->convert_to_pt("0.666667px");
        my $light_dot_stroke_width = $self->convert_to_pt("1.333333px");
        my $dot_stroke_width       = $self->convert_to_pt("2px");

        my $last_y_point = $height - $self->convert_to_pt("1in");

        # Compute the points.

        my @x_points = $self->get_points(
            spacing => $x_spacing,
            min     => 0,
            max     => $width,
            origin  => $x_origin,
            nearest_margin_line => $left_margin_line
        );

        my @y_points = $self->get_points(
            spacing => $y_spacing,
            min     => 0,
            max     => $height,
            origin  => $y_origin,
            ends_nearest_margins => 1
        );

        my @y_dot_points = $self->get_points(
            spacing => $y_spacing / 4,
            min     => 0,
            max     => $height,
            origin  => $y_origin
        );
        @y_dot_points = exclude(@y_dot_points, @y_points);

        my $real_left_margin_line = $self->point_nearest($left_margin_line, @x_points);

        my @x_dot_points = @x_points;
        @x_dot_points = exclude(@x_points, $real_left_margin_line);

        my $real_last_y_point = $self->point_nearest($last_y_point, @y_points);
        @y_points     = grep { $_ <= $real_last_y_point } @y_points;
        @y_dot_points = grep { $_ <= $real_last_y_point } @y_dot_points;

        # Draw the paper.

        my $doc = $self->doc(XML::LibXML::Document->new("1.0", "UTF-8"));

        my $viewBox = sprintf("%f %f %f %f", 0, 0, $width, $height);

        my $root = $doc->createElement("svg");
        $root->setAttribute("width", $width . "pt");
        $root->setAttribute("height", $height . "pt");
        $root->setAttribute("viewBox", $viewBox);
        $root->setAttribute("xmlns", "http://www.w3.org/2000/svg");
        $doc->setDocumentElement($root);

        # ff = 255
        # b3 = 179
        # 67 = 103
        # #b3b3ff => #6767ff
        # #b30000 => #670000
        my $style = $doc->createElement("style");
        my $css = <<"EOF";
            .line {
                stroke: #6767ff;
                stroke-linecap: round;
                stroke-width: ${line_stroke_width}pt;
                opacity: 0.5;
            }
            .dot {
                stroke: #6767ff;
                stroke-linecap: round;
                stroke-width: ${dot_stroke_width}pt;
                opacity: 0.5;
            }
            .light-dot {
                stroke: #6767ff;
                stroke-linecap: round;
                stroke-width: ${light_dot_stroke_width}pt;
                opacity: 0.5;
            }
            .margin-line {
                stroke: #670000;
                stroke-linecap: round;
                stroke-width: ${line_stroke_width}pt;
                opacity: 0.5;
            }
EOF
        $style->appendText($css);
        $root->appendChild($style);

        my $horizontal_lines = $doc->createElement("g");
        my $vertical_lines   = $doc->createElement("g");
        my $margin_lines     = $doc->createElement("g");
        my $dots             = $doc->createElement("g");

        $horizontal_lines->setAttribute("id", "horizontal-lines");
        $vertical_lines->setAttribute("id", "vertical-lines");
        $margin_lines->setAttribute("id", "margin-lines");
        $dots->setAttribute("id", "dots");

        $root->appendChild($horizontal_lines);
        $root->appendChild($vertical_lines);
        $root->appendChild($margin_lines);
        $root->appendChild($dots);

        foreach my $y (@y_points) {
            my $x1 = $left_margin;
            my $x2 = $right_margin;
            my $line = $self->create_line(
                x1 => $x1, x2 => $x2, y => $y,
                class => "line"
            );
            $horizontal_lines->appendChild($line);
        }

        foreach my $x (@x_dot_points) {
            foreach my $y (@y_dot_points) {
                my $line = $self->create_line(
                    x => $x, y => $y, class => "light-dot"
                );
                $horizontal_lines->appendChild($line);
            }
        }

        my $mline = $self->create_line(
            x => $real_left_margin_line,
            y1 => $bottom_margin,
            y2 => $top_margin,
            class => "margin-line"
        );
        $margin_lines->appendChild($mline);

        print $doc->toString(1);
    }

    sub get_points {
        my ($self, %args) = @_;
        my $spacing = $args{spacing};
        my $origin  = $args{origin};
        my $min     = $args{min};
        my $max     = $args{max};
        my $ends_nearest_margins = delete $args{ends_nearest_margins};
        my $nearest_margin_line = delete $args{nearest_margin_line};

        if ($ends_nearest_margins) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $min1 = $points1[0];

            my $min2 = $points2[0];
            if ($min1 < $min2) {
                return @points1;
            }
            return @points2;
        }

        if ($nearest_margin_line) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $point1 = $self->point_nearest($nearest_margin_line, @points1);
            my $point2 = $self->point_nearest($nearest_margin_line, @points2);
            my $dist1 = abs($point1 - $nearest_margin_line);
            my $dist2 = abs($point2 - $nearest_margin_line);
            if ($dist1 < $dist2) {
                return @points1;
            }
            return @points2;
        }

        my @points = ($origin);
        $spacing = $self->convert_to_pt($spacing);
        my $x;
        for ($x = $origin + $spacing; $x <= $max; $x += $spacing) {
            push(@points, $x);
        }
        for ($x = $origin - $spacing; $x >= $min; $x -= $spacing) {
            unshift(@points, $x);
        }
        return @points;
    }


    sub point_nearest {
        my ($self, $x, @points) = @_;
        my @dist = map { abs($x - $_) } @points;
        my $mindist = min(@points);
        for (my $i = 0; $i < scalar @points; $i += 1) {
            if ($mindist == $dist[$i]) {
                return $points[$i];
            }
        }
        return undef;
    }

    sub create_line {
        my ($self, %args) = @_;
        my $doc = $self->doc;
        my $line = $doc->createElement("line");
        my $x1 = $args{x1} // $args{x};
        my $x2 = $args{x2} // $args{x};
        my $y1 = $args{y1} // $args{y};
        my $y2 = $args{y2} // $args{y};
        $y1 = $self->height - $y1;
        $y2 = $self->height - $y2;
        $line->setAttribute("x1", $x1);
        $line->setAttribute("x2", $x2);
        $line->setAttribute("y1", $y1);
        $line->setAttribute("y2", $y2);
        $line->setAttribute("class", $args{class}) if defined $args{class};
        return $line;
    }
};

package My::Printable::Util {
    use base "Exporter";
    our @EXPORT_OK;
    BEGIN {
        push(@EXPORT_OK, 'exclude');
    }
    sub exclude(\@@) {
        my ($a, @b) = @_;
        my %b = map { ($_, 1) } @b;
        return grep { !$b{$_} } @$a;
    }
}
