#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

# on Cygwin:
#     apt-cyg install libpaper1 libpaper-bin
# on other systems:
#     it's part of something called libpaper.
#     git@github.com:naota/libpaper.git
# to list all paper sizes and their widths and heights:
#     paperconf -a -n -s
# to get the default paper size:
#     paperconf

our $opt_papersize;
our $opt_width;
our $opt_height;

use Getopt::Long;
use Data::Dumper;
use Carp::Always;

Getopt::Long::Configure(qw(bundling gnu_compat no_ignore_case));
Getopt::Long::GetOptions(
    "M|p|media|paper|paper-size=s" => \$opt_papersize,
    "w|width=s"                    => \$opt_width,
    "h|height=s"                   => \$opt_height,
    "help|?" => sub {
        usage();
        exit(0);
    }
) or die("Type '$0 --help' for help.\n");

sub usage { print <<"EOF"; }
usage:
    $0 [<option> ...]
options:
    -M, -p, --media, --paper, --paper-size=<paper-size-name>|<custom-paper-size>
        Specify paper size (run paperconf -a -n -s to list paper sizes)
    -w, --width=<width>
    -h, --height=<height>
    -?, --help
<width> or <height>:
    <number> [<unit>]           <unit> defaults to pt
    <number>/<number> [<unit>]
<custom-paper-size>:
    <width> *|x <height>        height <unit> defaults to pt;
                                width <unit> defaults to same <unit> as height
examples:
    --width=8.5in       --paper-size='8.5in x 11in'     --paper-size=letter
    --width=612         --paper-size='612*792'
    --height=297mm      --paper-size='210.224x297.302mm'
###############################################################################
EOF

my $p = My::Printable->new();
$p->set_papersize($opt_papersize) if defined $opt_papersize;
$p->set_width($opt_width)         if defined $opt_width;
$p->set_height($opt_height)       if defined $opt_height;

if (!scalar @ARGV) {
    die("No paper ruling argument specified.\n");
}

foreach my $arg (@ARGV) {
    $p->generate_paper($arg);
}

package My::Printable {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;

    INIT {
        public papersize, default => "letter";
        public width,     default => 612;
        public height,    default => 792;

        public doc;
        public root;

        public canvas;
        public ruling;
        public left_margin;
        public right_margin;
        public bottom_margin;
        public top_margin;
        public x_origin;
        public y_origin;

        public unit;
        public unit_x;
        public unit_y;
    }

    sub init {
        my ($self) = @_;
        $self->unit(My::Printable::Unit->new);
        $self->unit_x(My::Printable::Unit->new);
        $self->unit_y(My::Printable::Unit->new);
    }

    use XML::LibXML;
    use List::Util qw(min max);
    use Data::Dumper;
    use POSIX qw(round);

    # use My::Printable::Util qw(exclude);
    sub exclude(\@@);      # for embedded package subs with prototypes
    INIT {
        import My::Printable::Util qw(exclude);
    }

    our $RULINGS;
    BEGIN {
        $RULINGS = {
            dot_grid__one_quarter_inch => {
                unit => "1/4in",
                dot_grid => {
                    x_spacing => "1/4in",
                    y_spacing => "1/4in",
                    class => "blue dot",
                },
                left_margin_line => {
                    x => "1.25in",
                    nearest => "dot-grid",
                    class => "red margin-line",
                },
            },
            line_dot_grid__five_sixteenths_inch => {
                unit => "5/16in",
                dot_grid => {
                    x_spacing => "5/16in",
                    y_spacing => "5/64in",
                    class => "thin blue dot",
                },
                horizontal_lines => {
                    y_spacing => "5/16in",
                    ends_nearest_margins => 1,
                    bottom => "1in",
                    top => "1.5in",
                    class => "thin blue line",
                },
                left_margin_line => {
                    x => "1.25in",
                    nearest => "dot-grid",
                    class => "red margin-line",
                },
            },
            seyes__five_sixteenths_inch => {
                unit => "5/16in",
                horizontal_lines => {
                    y_spacing => "5/16in",
                    bottom => "1in",
                    top => "1.5in",
                    class => "thin blue line",
                    minor => {
                        every => 4,
                        extra => {
                            bottom => 2,
                            top => 3,
                        },
                        class => "super-thin light blue line",
                    },
                },
                vertical_lines => {
                    x_spacing => "5/16in",
                    ends_nearest_margins => 1,
                    class => "super-thin light blue line",
                },
                left_margin_line => {
                    x => "1.25in",
                    nearest => "vertical-lines",
                    class => "red margin-line"
                }
            },
            seyes_gray__five_sixteenths_inch => {
                unit => "5/16in",
                horizontal_lines => {
                    y_spacing => "5/16in",
                    bottom => "1in",
                    top => "1.5in",
                    class => "gray line",
                    minor => {
                        every => 4,
                        extra => {
                            bottom => 2,
                            top => 3,
                        },
                        class => "thin gray line",
                    },
                },
                vertical_lines => {
                    x_spacing => "5/16in",
                    ends_nearest_margins => 1,
                    class => "thin gray line",
                },
                left_margin_line => {
                    x => "1.25in",
                    nearest => "vertical-lines",
                    class => "dark gray margin-line"
                }
            },
        };
    }

    sub set_papersize {
        my ($self, $spec) = @_;
        my ($papersize, $width, $height, $type) = $self->read_papersize($spec);
        $self->papersize($papersize);
        $self->width($width);
        $self->height($height);
        $self->unit_x->set_percentage_basis($width);
        $self->unit_y->set_percentage_basis($height);
    }

    sub set_width {
        my ($self, $value, $unit) = @_;
        my ($pt, $type) = $self->unit->convert_to_pt($value, $unit);
        $self->width($pt);
        $self->papersize(undef);
        $self->unit_x->set_percentage_basis($pt);
    }

    sub set_height {
        my ($self, $value, $unit) = @_;
        my ($pt, $type) = $self->unit->convert_to_pt($value, $unit);
        $self->height($pt);
        $self->papersize(undef);
        $self->unit_y->set_percentage_basis($pt);
    }

    sub parse_custom_papersize {
        my ($self, $papersize) = @_;


        my $rx_number = $self->unit->rx_number;
        my $rx_units  = $self->unit->rx_units;

        if (defined $papersize && $papersize =~ m{\A
                                                  ($rx_number)
                                                  (?:
                                                      \s*
                                                      /
                                                      \s*
                                                      ($rx_number)
                                                  )?
                                                  \s*
                                                  ($rx_units)?
                                                  \s*
                                                  (?:\*|x)
                                                  \s*
                                                  ($rx_number)
                                                  (?:
                                                      \s*
                                                      /
                                                      \s*
                                                      ($rx_number)
                                                  )?
                                                  \s*
                                                  ($rx_units)?
                                                  \z}xi) {
            my ($width, $width_denominator, $x_unit,
                $height, $height_denominator, $y_unit) = ($1, $2, $3, $4, $5, $6);
            $width  /= $width_denominator  if defined $width_denominator;
            $height /= $height_denominator if defined $height_denominator;

            if (!defined $y_unit || $y_unit eq "") {
                $y_unit = "pt";
            }
            if (!defined $x_unit || $x_unit eq "") {
                $x_unit = $y_unit;
            }

            my $x_type;
            my $y_type;
            ($width,  $x_type) = $self->unit_x->convert_to_pt($width,  $x_unit);
            ($height, $y_type) = $self->unit_y->convert_to_pt($height, $y_unit);

            my $type = $x_type // $y_type;
            if (wantarray) {
                return (undef, $width, $height, $type);
            }
            return {
                width  => $width,
                height => $height,
                type   => $type
            };
        }
        return;
    }

    our $SIZES;
    INIT {
        $SIZES = {
            letter => {
                width  => scalar(My::Printable::Unit->convert_to_pt(8.5, "in")),
                height => scalar(My::Printable::Unit->convert_to_pt(11, "in")),
                type   => "imperial",
            },
            a4 => {
                width  => scalar(My::Printable::Unit->convert_to_pt(250 / sqrt(sqrt(2)), "mm")),
                height => scalar(My::Printable::Unit->convert_to_pt(250 * sqrt(sqrt(2)), "mm")),
                type   => "metric",
            },
        };
    }

    sub get_papersize {
        my ($self, $papersize) = @_;
        my $papersizename;
        my $width;
        my $height;
        my $type;
        my $lc_papersize = lc $papersize;
        if (exists $SIZES->{$lc_papersize}) {
            $papersizename = $lc_papersize;
            $width  = $SIZES->{$lc_papersize}->{width};
            $height = $SIZES->{$lc_papersize}->{height};
            $type   = $SIZES->{$lc_papersize}->{type};
        } else {
            my $ph;
            my @cmd;
            if (defined $papersize) {
                @cmd = ("paperconf", "-p", $papersize, "-n", "-s");
            } else {
                @cmd = ("paperconf", "-n", "-s");
            }
            if (!open($ph, "-|", @cmd)) {
                die("exec paperconf: $!");
            }
            local $/ = undef;
            my $result = <$ph>;
            if (!close($ph)) {
                die("paperconf failed: $!");
            }
            $result =~ s{\A\s+}{};
            $result =~ s{\s+\z}{};
            ($papersizename, $width, $height) = split(' ', $result);
            if ($width == round($width) && $height == round($height)) {
                $type = "imperial";
            } else {
                $type = "metric";
            }
        }
        if (wantarray) {
            return ($papersizename, $width, $height, $type);
        }
        return {
            papersize => $papersizename,
            width     => $width,
            height    => $height,
            type      => $type
        };
    }

    sub read_papersize {
        my ($self, $papersize) = @_;
        my ($x, $y, $type) = $self->parse_custom_papersize($papersize);
        if (defined $x && defined $y) {
            if (wantarray) {
                return (undef, $x, $y);
            }
            return {
                width => $x,
                height => $y
            };
        }
        return $self->get_papersize($papersize);
    }

    sub generate_line_dot_grid_paper {
        my ($self, %args) = @_;
        $self->generate_paper("five_sixteenths_inch_line_dot_grid", %args);
    }

    sub generate_dot_grid_paper {
        my ($self, %args) = @_;
        $self->generate_paper("one_quarter_inch_dot_grid", %args);
    }

    sub generate_paper {
        my ($self, $ruling_name, %args) = @_;

        $ruling_name =~ s{-}{_}g;

        my $ruling = $RULINGS->{$ruling_name};
        if (!$ruling) {
            die("No such ruling: $ruling_name\n");
        }

        my $width  = $self->width;
        my $height = $self->height;

        my $left_margin  = $self->unit_x->convert_to_pt($ruling->{left_margin} // 0);
        my $right_margin = $self->width - $self->unit_x->convert_to_pt($ruling->{right_margin} // 0);

        my $bottom_margin = $self->unit_y->convert_to_pt($ruling->{bottom_margin} // 0);
        my $top_margin    = $self->height - $self->unit_y->convert_to_pt($ruling->{top_margin} // 0);

        my $x_origin = $self->unit_x->convert_to_pt($ruling->{x_origin} // "50%");
        my $y_origin = $self->unit_y->convert_to_pt($ruling->{y_origin} // "50%");

        $self->left_margin($left_margin);
        $self->right_margin($right_margin);
        $self->bottom_margin($bottom_margin);
        $self->top_margin($top_margin);
        $self->x_origin($x_origin);
        $self->y_origin($y_origin);

        my $doc = $self->create_document;
        my $root = $self->root;

        my $style = $self->create_style_element;
        $root->appendChild($style);

        $self->ruling($ruling);
        my $canvas           = $self->canvas({});
        my $dot_grid         = $canvas->{dot_grid}         = {};
        my $horizontal_lines = $canvas->{horizontal_lines} = {};
        my $vertical_lines   = $canvas->{vertical_lines}   = {};
        my $margin_lines     = $canvas->{margin_lines}     = {};

        # Compute points

        $self->compute_dot_grid;
        $self->compute_horizontal_lines;
        $self->compute_vertical_lines;
        $self->compute_margin_lines;

        $self->chop_horizontal_lines;
        $self->compute_minor_horizontal_lines;

        $self->chop_vertical_lines;

        $self->relocate_margin_lines;

        $self->filter_grid_points;

        # Draw everything.

        $self->draw_dot_grid;
        $self->draw_minor_horizontal_lines;
        $self->draw_vertical_lines;
        $self->draw_horizontal_lines;
        $self->draw_margin_lines;

        print $doc->toString(1);
    }

    sub compute_dot_grid {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $dot_grid = $self->canvas->{dot_grid};
        if ($ruling->{dot_grid}) {
            my $x_spacing = $dot_grid->{x_spacing} = $self->unit_x->convert_to_pt($ruling->{dot_grid}->{x_spacing});
            my $y_spacing = $dot_grid->{y_spacing} = $self->unit_y->convert_to_pt($ruling->{dot_grid}->{y_spacing});
$dot_grid->{x} = $self->get_points(
                spacing => $x_spacing,
                min => $self->left_margin,
                max => $self->right_margin,
                origin => $self->x_origin,
                ends_nearest_margins => 1
            );
            $dot_grid->{y} = $self->get_points(
                spacing => $y_spacing,
                min => $self->bottom_margin,
                max => $self->top_margin,
                origin => $self->y_origin,
                ends_nearest_margins => 1
            );
        }
    }

    sub compute_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $horizontal_lines = $self->canvas->{horizontal_lines};
        my $dot_grid = $self->canvas->{dot_grid};
        if ($ruling->{horizontal_lines}) {
            my $y_spacing = $horizontal_lines->{y_spacing} = $self->unit_y->convert_to_pt($ruling->{horizontal_lines}->{y_spacing});
my $our_y_origin = $self->y_origin;
            if ($ruling->{dot_grid}) {
                $our_y_origin = $dot_grid->{y}->[0];
            }
            $horizontal_lines->{y} = $self->get_points(
                spacing => $y_spacing,
                min => $self->bottom_margin,
                max => $self->top_margin,
                origin => $our_y_origin,
                ends_nearest_margins => 1
            );
        }
    }

    sub compute_vertical_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $vertical_lines = $self->canvas->{vertical_lines};
        my $dot_grid = $self->canvas->{dot_grid};
        if ($ruling->{vertical_lines}) {
            my $x_spacing = $vertical_lines->{x_spacing} = $self->unit_x->convert_to_pt($ruling->{vertical_lines}->{x_spacing});
            my $our_x_origin = $self->x_origin;
            if ($ruling->{dot_grid}) {
                $our_x_origin = $dot_grid->{x}->[0];
            }
            $vertical_lines->{x} = $self->get_points(
                spacing => $x_spacing,
                min => $self->left_margin,
                max => $self->right_margin,
                origin => $our_x_origin,
                ends_nearest_margins => 1
            );
        }
    }

    sub compute_margin_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $margin_lines = $self->canvas->{margin_lines};
        if ($ruling->{left_margin_line}) {
            $margin_lines->{left}->{x} = $self->unit_x->convert_to_pt($ruling->{left_margin_line}->{x});
        }
    }

    sub chop_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $horizontal_lines = $self->canvas->{horizontal_lines};
        my $height = $self->height;
        if ($ruling->{horizontal_lines}) {
            my $y = $horizontal_lines->{y};

            my $bottom = $ruling->{horizontal_lines}->{bottom};
            if (defined $bottom) {
                my $bottom_y = $self->unit_y->convert_to_pt($bottom);
                $bottom_y = $self->point_nearest($bottom_y, @$y);
                @$y = grep { $_ >= $bottom_y } @$y;
            }

            my $top = $ruling->{horizontal_lines}->{top};
            if (defined $top) {
                my $top_y = $height - $self->unit_y->convert_to_pt($top);
                $top_y = $self->point_nearest($top_y, @$y);
                @$y = grep { $_ <= $top_y } @$y;
            }
        }
    }

    sub chop_vertical_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $vertical_lines = $self->canvas->{vertical_lines};
        my $width = $self->width;
        if ($ruling->{vertical_lines}) {
            my $x = $vertical_lines->{x};

            my $left = $ruling->{vertical_lines}->{left};
            if (defined $left) {
                my $left_x = $self->unit_x->convert_to_pt($left);
                $left_x = $self->point_nearest($left_x, @$x);
                @$x = grep { $_ >= $left_x } @$x;
            }

            my $right = $ruling->{vertical_lines}->{right};
            if (defined $right) {
                my $right_x = $width - $self->unit_x->convert_to_pt($right);
                $right_x = $self->point_nearest($right_x, @$x);
                @$x = grep { $_ <= $right_x } @$x;
            }
        }
    }

    sub compute_minor_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $horizontal_lines = $self->canvas->{horizontal_lines};
        if ($ruling->{horizontal_lines}) {
            my $minor = $ruling->{horizontal_lines}->{minor};
            if (defined $minor) {
                my $y = $horizontal_lines->{y};
                my $every = $minor->{every};
                my $extra = $minor->{extra};
                my $extra_bottom = ($extra && $extra->{bottom}) // 0;
                my $extra_top    = ($extra && $extra->{top})    // 0;
                my $y_bottom = min @$y;
                my $y_top    = max @$y;
                my $y_spacing = $horizontal_lines->{y_spacing} / $every;
                my $new_y_bottom = $y_bottom - ($extra_bottom + 0.5) * $y_spacing;
                my $new_y_top    = $y_top    + ($extra_top    + 0.5) * $y_spacing;
                my $minor_y = $horizontal_lines->{minor}->{y} = $self->get_points(
                    spacing => $y_spacing,
                    min => $new_y_bottom,
                    max => $new_y_top,
                    origin => $y_bottom
                );
                @$minor_y = exclude(@$minor_y, @{$horizontal_lines->{y}});
            }
        }
    }

    sub relocate_margin_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $margin_lines = $self->canvas->{margin_lines};
        my $dot_grid = $self->canvas->{dot_grid};

        my $vertical_lines = $self->canvas->{vertical_lines};
        if ($ruling->{left_margin_line}) {
            my $nearest = $ruling->{left_margin_line}->{nearest};
            if (defined $nearest) {
                if ($nearest eq "dot-grid" && $ruling->{dot_grid}) {
                    $margin_lines->{left}->{x} = $self->point_nearest($margin_lines->{left}->{x},
                                                                      @{$dot_grid->{x}});
                }
                if ($nearest eq "vertical-lines" && $ruling->{vertical_lines}) {
                    $margin_lines->{left}->{x} = $self->point_nearest($margin_lines->{left}->{x},
                                                                      @{$vertical_lines->{x}});
                }
            }
        }
    }

    sub filter_grid_points {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $margin_lines = $self->canvas->{margin_lines};
        my $dot_grid = $self->canvas->{dot_grid};
        my $horizontal_lines = $self->canvas->{horizontal_lines};
        my $vertical_lines = $self->canvas->{vertical_lines};

        if ($ruling->{dot_grid}) {
            my $x = $dot_grid->{x};
            my $y = $dot_grid->{y};
            if ($ruling->{horizontal_lines}) {
                @$y = exclude(@$y, @{$horizontal_lines->{y}});
            }
            if ($ruling->{horizontal_lines}->{minor}) {
                @$y = exclude(@$y, @{$horizontal_lines->{minor}->{y}});
            }
            if ($ruling->{vertical_lines}) {
                @$x = exclude(@$x, @{$vertical_lines->{x}});
            }
            if ($ruling->{left_margin_line}) {
                @$x = exclude(@$x, ($margin_lines->{left}->{x}));
            }
        }
    }


    sub draw_dot_grid {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $dot_grid = $self->canvas->{dot_grid};
        if ($ruling->{dot_grid}) {
            my $layer = $self->layer("dot-grid");
            foreach my $x (@{$dot_grid->{x}}) {
                foreach my $y (@{$dot_grid->{y}}) {
                    my $line = $self->create_line(
                        x => $x, y => $y,
                        class => $ruling->{dot_grid}->{class} // "thin blue dot"
                    );
                    $layer->appendChild($line);
                }
            }
        }
    }

    sub draw_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $horizontal_lines = $self->canvas->{horizontal_lines};
        if ($ruling->{horizontal_lines}) {
            my $layer = $self->layer("horizontal-lines");
            foreach my $y (@{$horizontal_lines->{y}}) {
                my $x1 = $self->left_margin;
                my $x2 = $self->right_margin;
                my $line = $self->create_line(
                    x1 => $x1, x2 => $x2, y => $y,
                    class => $ruling->{horizontal_lines}->{class} // "thin blue line"
                );
                $layer->appendChild($line);
            }
        }
    }

    sub draw_minor_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $horizontal_lines = $self->canvas->{horizontal_lines};
        if ($ruling->{horizontal_lines} && $ruling->{horizontal_lines}->{minor}) {
            my $layer = $self->layer("minor-horizontal-lines");
            my $minor = $horizontal_lines->{minor};
            if (defined $minor) {
                foreach my $y (@{$minor->{y}}) {
                    my $x1 = $self->left_margin;
                    my $x2 = $self->right_margin;
                    my $line = $self->create_line(
                        x1 => $x1, x2 => $x2, y => $y,
                        class => $ruling->{horizontal_lines}->{minor}->{class} // "super-thin blue line"
                    );
                    $layer->appendChild($line);
                }
            }
        }
    }

    sub draw_vertical_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $vertical_lines = $self->canvas->{vertical_lines};
        if ($ruling->{vertical_lines}) {
            my $layer = $self->layer("vertical-lines");
            foreach my $x (@{$vertical_lines->{x}}) {
                my $y1 = $self->bottom_margin;
                my $y2 = $self->top_margin;
                my $line = $self->create_line(
                    y1 => $y1, y2 => $y2, x => $x,
                    class => $ruling->{vertical_lines}->{class} // "thin blue line"
                );
                $layer->appendChild($line);
            }
        }
    }

    sub draw_margin_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $margin_lines = $self->canvas->{margin_lines};
        if ($ruling->{left_margin_line}) {
            my $layer = $self->layer("margin-lines");
            my $margin_line = $self->create_line(
                x => $margin_lines->{left}->{x},
                y1 => $self->bottom_margin,
                y2 => $self->top_margin,
                class => $ruling->{left_margin_line}->{class} // "red margin-line"
            );
            $layer->appendChild($margin_line);
        }
    }

    sub get_points {
        my ($self, %args) = @_;
        my $spacing = $args{spacing};
        my $origin  = $args{origin};
        my $min     = $args{min};
        my $max     = $args{max};
        my $ends_nearest_margins = delete $args{ends_nearest_margins};
        my $nearest_margin_line = delete $args{nearest_margin_line};

        if ($ends_nearest_margins) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $min1 = $points1[0];

            my $min2 = $points2[0];
            if ($min1 < $min2) {
                return @points1 if wantarray;
                return \@points1;
            }
            return @points2 if wantarray;
            return \@points2;
        }

        if ($nearest_margin_line) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $point1 = $self->point_nearest($nearest_margin_line, @points1);
            my $point2 = $self->point_nearest($nearest_margin_line, @points2);
            my $dist1 = abs($point1 - $nearest_margin_line);
            my $dist2 = abs($point2 - $nearest_margin_line);
            if ($dist1 < $dist2) {
                return @points1 if wantarray;
                return \@points1;
            }
            return @points2 if wantarray;
            return \@points2;
        }

        my @points = ($origin);
        $spacing = $self->unit->convert_to_pt($spacing);
        my $x;
        for ($x = $origin + $spacing; $x <= $max; $x += $spacing) {
            push(@points, $x);
        }
        for ($x = $origin - $spacing; $x >= $min; $x -= $spacing) {
            unshift(@points, $x);
        }
        return @points if wantarray;
        return \@points;
    }


    sub point_nearest {
        my ($self, $x, @points) = @_;
        my @dist = map { abs($x - $_) } @points;
        my $mindist = min(@dist);
        for (my $i = 0; $i < scalar @points; $i += 1) {
            if ($mindist == $dist[$i]) {
                return $points[$i];
            }
        }
        return undef;           # should NEVER happen.
    }

    sub create_line {
        my ($self, %args) = @_;
        my $doc = $self->doc;
        my $line = $doc->createElement("line");
        my $x1 = $args{x1} // $args{x};
        my $x2 = $args{x2} // $args{x};
        my $y1 = $args{y1} // $args{y};
        my $y2 = $args{y2} // $args{y};
        $y1 = $self->height - $y1;
        $y2 = $self->height - $y2;
        $line->setAttribute("x1", $x1);
        $line->setAttribute("x2", $x2);
        $line->setAttribute("y1", $y1);
        $line->setAttribute("y2", $y2);
        $line->setAttribute("class", $args{class}) if defined $args{class};
        return $line;
    }

    sub create_document {
        my ($self) = @_;
        my $width = $self->width;
        my $height = $self->height;
        my $viewBox = sprintf("%f %f %f %f", 0, 0, $width, $height);
        my $doc = $self->doc(XML::LibXML::Document->new("1.0", "UTF-8"));
        my $root = $self->root($doc->createElement("svg"));
        $root->setAttribute("width", $width . "pt");
        $root->setAttribute("height", $height . "pt");
        $root->setAttribute("viewBox", $viewBox);
        $root->setAttribute("xmlns", "http://www.w3.org/2000/svg");
        $doc->setDocumentElement($root);
        return $doc;
    }

    # ff = 255
    # d9 = 217
    # b3 = 179
    # 67 = 103
    # #b3b3ff => #6767ff
    # #b30000 => #670000
    sub create_style_element {
        my ($self, $css) = @_;

        my $super_thin_line_stroke_width = $self->unit->convert_to_pt("1/600in");
        my $thin_line_stroke_width       = $self->unit->convert_to_pt("1/300in");
        my $line_stroke_width             = $self->unit->convert_to_pt("2/300in");
        my $thick_line_stroke_width       = $self->unit->convert_to_pt("3/300in");

        my $thin_dot_stroke_width        = $self->unit->convert_to_pt("4/300in");
        my $dot_stroke_width              = $self->unit->convert_to_pt("6/300in");
        my $thick_dot_stroke_width        = $self->unit->convert_to_pt("9/300in");

        $css //= <<"EOF";
            .line {
                stroke-linecap: round;
                stroke-width: ${line_stroke_width}pt;
            }
            .dot {
                stroke-linecap: round;
                stroke-width: ${dot_stroke_width}pt;
            }
            .margin-line {
                stroke-linecap: round;
                stroke-width: ${line_stroke_width}pt;
            }

            .blue {
                stroke: #b3b3ff;
            }
            .red {
                stroke: #b30000;
            }
            .green {
                stroke: #b3ffb3;
            }
            .gray {
                stroke: #b3b3b3;
            }

            .light.blue {
                stroke: #d9d9ff;
            }
            .light.red {
                stroke: #d98080;
            }
            .light.green {
                stroke: #d9ffd9;
            }
            .light.gray {
                stroke: #d9d9d9;
            }

            .dark.blue {
                stroke: #6767ff;
            }
            .dark.red {
                stroke: #670000;
            }
            .dark.green {
                stroke: #67ff67;
            }
            .dark.gray {
                stroke: #676767;
            }

            .alternate-blue {
                stroke: #6767ff;
                opacity: 0.5;
            }
            .alternate-red {
                stroke: #670000;
                opacity: 0.5;
            }
            .alternate-green {
                stroke: #67ff67;
                opacity: 0.5;
            }
            .alternate-gray {
                stroke: #676767;
                opacity: 0.5;
            }

            .line.super-thin {
                stroke-width: ${super_thin_line_stroke_width}pt;
            }
            .line.thin {
                stroke-width: ${thin_line_stroke_width}pt;
            }
            .line.thick {
                stroke-width: ${thick_line_stroke_width}pt;
            }

            .dot.thin {
                stroke-width: ${thin_dot_stroke_width}pt;
            }
            .dot.thick {
                stroke-width: ${thick_dot_stroke_width}pt;
            }

            .margin-line.thin {
                stroke-width: ${thin_line_stroke_width}pt;
            }
            .margin-line.thick {
                stroke-width: ${thick_line_stroke_width}pt;
            }
EOF
        my $doc = $self->doc;
        my $style = $doc->createElement("style");
        $style->appendText($css);
        return $style;
    }

    sub create_g_element {
        my ($self, $id) = @_;
        my $doc = $self->doc;
        my $g = $doc->createElement("g");
        $g->setAttribute("id", $id);
        return $g;
    }

    sub layer {
        my ($self, $id) = @_;
        my $doc = $self->doc;
        my $root = $self->root;
        my ($layer) = $doc->findnodes("//*[\@id='" . $id . "']");
        if ($layer) {
            return $layer;
        }
        $layer = $self->create_g_element($id);
        $root->appendChild($layer);
        return $layer;
    }
};

package My::Printable::Unit {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;

    our $UNITS;
    BEGIN {
        $UNITS = {
            "pt" => {
                to_pt => 1,
                type => "imperial",
            },
            "pc" => {
                to_pt => 12,    # 1 pc = 12 pt
                type => "imperial",
            },
            "in" => {
                to_pt => 72,    # 1 in = 72 pt
                type => "imperial",
            },
            "cm" => {
                to_pt => (72 / 2.54), # 1 cm ~= 28.3465 pt
                type => "metric",
            },
            "mm" => {
                to_pt => (72 / 25.4), # 1 cm ~= 2.83465 pt
                type => "metric",
            },
            "px" => {
                to_pt => (72 / 96), # 1 px = 0.75 pt
                type => "imperial"
            },
            "pd" => {           # pixel dots
                to_pt => (72 / 300), # 1 pd = 1 dot on a 300dpi laser printer = 1/300 in = 72/300 pt
                type => "imperial"
            }
        };
    }

    sub init {
        my ($self) = @_;
        $self->{units} = { %$UNITS }; # shallow copy
    }

    sub set_percentage_basis {
        my ($self, $value, $unit) = @_;
        delete $self->{units}->{'%'};
        $self->add_unit('%', $value / 100, $unit);
    }

    sub add_unit {
        my ($self, $unit, $value, $value_unit) = @_;
        die("Unit already defined: $unit\n") if exists $self->{units}->{$unit};
        my ($pt, $type) = $self->convert_to_pt($value, $value_unit);
        $self->{units}->{$unit} = {
            to_pt => $pt,
            type => $type
        };
    }

    sub rx_units {
        my ($self) = @_;
        $self = object($self);

        my @units = sort keys %{$self->{units}};
        my $units = join('|', map { quotemeta($_) } @units);
        return qr{$units}xi;
    }

    sub rx_number {
        my ($self) = @_;
        $self = object($self);

        return qr{\d+(?:\.\d*)?|\.\d+}ix;
    }

    sub convert_to_pt {
        my ($self, $value, $unit) = @_;
        $self = object($self);

        my ($numerator, $denominator);

        my $rx_units  = $self->rx_units;
        my $rx_number = $self->rx_number;
        my $spec;

        if (defined $unit) {
            $spec = "$value $unit";
            if ($value =~ m{\A
                            \s*
                            ($rx_number)
                            (?:
                                \s*
                                /
                                \s*
                                ($rx_number)
                            )?
                            \s*
                            \z}xi) {
                ($numerator, $denominator) = ($1, $2);
            } else {
                die("Invalid size specification: $value $unit\n");
            }
        } else {
            $spec = "$value";
            if ($value =~ m{\A
                            \s*
                            ($rx_number)
                            (?:
                                \s*
                                /
                                \s*
                                ($rx_number)
                            )?
                            \s*
                            ($rx_units)?
                            \s*
                            \z}xi) {
                ($numerator, $denominator, $unit) = ($1, $2, $3);
            } else {
                die("Invalid size specification: $spec\n");
            }
        }

        my $number;
        if (defined $denominator) {
            $number = $numerator / $denominator;
        } else {
            $number = $numerator;
        }

        if (!defined $unit || $unit eq "") {
            return ($number, "imperial") if wantarray;
            return $number;
        }

        my $unit_info = $self->{units}->{$unit};
        if (!defined $unit_info) {
            die("Invalid size specification: $spec\n");
        }

        my $result_pt   = $number * $unit_info->{to_pt};
        my $result_type = $unit_info->{type};

        return ($result_pt, $result_type) if wantarray;
        return $result_pt;
    }

    our $SINGLETON;

    sub object {
        my ($self) = @_;
        if (!ref $self) {
            $self = ($SINGLETON //= __PACKAGE__->new);
        }
        return $self;
    }
};

package My::Printable::Util {
    use base "Exporter";

    our @EXPORT_OK;
    BEGIN {
        push(@EXPORT_OK, 'exclude');
    }

    use Data::Dumper;

    sub exclude(\@@);
    sub exclude(\@@) {
        my ($a, @b) = @_;
        my %b = map { ($_, 1) } @b;
        return grep { !$b{$_} } @$a;
    }
};
