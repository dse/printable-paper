#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

# on Cygwin:
#     apt-cyg install libpaper1 libpaper-bin
# to list all paper sizes and their widths and heights:
#     paperconf -a -n -s
# to get the default paper size:
#     paperconf

our $opt_papersize;
our $opt_width;
our $opt_height;

use Getopt::Long;
use Data::Dumper;
use Carp::Always;

Getopt::Long::Configure(qw(bundling gnu_compat));
Getopt::Long::GetOptions(
    "M|p|media|paper|paper-size=s" => \$opt_papersize,
    "w|width=s"                    => \$opt_width,
    "h|height=s"                   => \$opt_height,
    "?|help" => sub {
        usage();
        exit(0);
    }
) or die("Type '$0 --help' for help.\n");

sub usage { print <<"EOF"; }
usage:
    $0 [<option> ...]
options:
    -M, -p, --media, --paper, --paper-size=<paper-size-name>|<custom-paper-size>
        Specify paper size (run paperconf -a -n -s to list paper sizes)
    -w, --width=<width>
    -h, --height=<height>
    -?, --help
<width> or <height>:
    <number> [<unit>]           <unit> defaults to pt
    <number>/<number> [<unit>]
<custom-paper-size>:
    <width> *|x <height>        height <unit> defaults to pt;
                                width <unit> defaults to same <unit> as height
examples:
    --width=8.5in       --paper-size='8.5in x 11in'     --paper-size=letter
    --width=612         --paper-size='612*792'
    --height=297mm      --paper-size='210.224x297.302mm'
###############################################################################
EOF

my $p = My::Printable->new();
$p->set_papersize($opt_papersize) if defined $opt_papersize;
$p->set_width($opt_width)         if defined $opt_width;
$p->set_height($opt_height)       if defined $opt_height;

if (!scalar @ARGV) {
    @ARGV = ("line-dot-grid-paper");
}

foreach my $arg (@ARGV) {
    if ($arg eq "dot-grid") {
        $p->generate_dot_grid_paper;
    } elsif ($arg eq "line-dot-grid") {
        $p->generate_line_dot_grid_paper;
    }
}

package My::Printable {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;
    INIT {
        public papersize, default => "letter";
        public width,     default => 612;
        public height,    default => 792;
        public doc;
        public root;
    }

    use XML::LibXML;
    use List::Util qw(min);

    # use My::Printable::Util qw(exclude);
    sub exclude(\@@);      # for embedded package subs with prototypes
    INIT {
        import My::Printable::Util qw(exclude);
    }

    our $units;
    BEGIN {
        $units = {
            "pt" => {
                to_pt => 1,
                type => "imperial",
            },
            "pc" => {
                to_pt => 12,    # 1 pc = 12 pt
                type => "imperial",
            },
            "in" => {
                to_pt => 72,    # 1 in = 72 pt
                type => "imperial",
            },
            "cm" => {
                to_pt => (72 / 2.54), # 1 cm ~= 28.3465 pt
                type => "metric",
            },
            "mm" => {
                to_pt => (72 / 25.4), # 1 cm ~= 2.83465 pt
                type => "metric",
            },
            "px" => {
                to_pt => (72 / 96), # 1 px = 0.75 pt
                type => "imperial"
            },
            "pd" => {           # pixel dots
                to_pt => (72 / 300), # 1 pd = 1 dot on a 300dpi laser printer = 1/300 in = 72/300 pt
                type => "imperial"
            }
        };
    }

    our $rx_units;
    our $rx_number;
    BEGIN {
        $rx_units = qr{in|px|pt|cm|mm|pd}ix;
        $rx_number = qr{\d+(?:\.\d*)?|\.\d+}ix;
    }

    sub set_papersize {
        my ($self, $spec) = @_;
        my ($papersize, $width, $height) = $self->read_papersize($spec);
        $self->papersize($papersize);
        $self->width($width);
        $self->height($height);
    }

    sub set_width {
        my ($self, $width) = @_;
        my $result = $self->convert_to_pt($width);
        $self->width($result);
        $self->papersize(undef);
    }

    sub set_height {
        my ($self, $height) = @_;
        my $result = $self->convert_to_pt($height);
        $self->height($result);
        $self->papersize(undef);
    }

    sub convert_to_pt {
        my ($self, $value) = @_;
        if ($value =~ m{\A
                        \s*
                        ($rx_number)
                        (?:
                            \s*
                            /
                            \s*
                            ($rx_number)
                        )?
                        \s*
                        ($rx_units)?
                        \s*
                        \z}xi) {
            my ($number, $denominator, $unit) = ($1, $2, $3);
            if (defined $denominator) {
                $number /= $denominator;
            }
            if (!defined $unit || $unit eq "") {
                return $number;
            }
            return $number * $units->{$unit}->{to_pt};
        } else {
            die("Invalid size specification: $value\n");
        }
    }

    sub parse_custom_papersize {
        my ($self, $papersize) = @_;
        if (defined $papersize && $papersize =~ m{\A
                                                  ($rx_number)
                                                  (?:
                                                      \s*
                                                      /
                                                      \s*
                                                      ($rx_number)
                                                  )?
                                                  \s*
                                                  ($rx_units)?
                                                  \s*
                                                  (?:\*|x)
                                                  \s*
                                                  ($rx_number)
                                                  (?:
                                                      \s*
                                                      /
                                                      \s*
                                                      ($rx_number)
                                                  )?
                                                  \s*
                                                  ($rx_units)?
                                                  \z}xi) {
            my ($width, $width_denominator, $x_unit,
                $height, $height_denominator, $y_unit) = ($1, $2, $3, $4, $5, $6);
            $width /= $width_denominator if defined $width_denominator;
            $height /= $height_denominator if defined $height_denominator;
            if (!defined $y_unit || $y_unit eq "") {
                $y_unit = "pt";
            }
            if (!defined $x_unit || $x_unit eq "") {
                $x_unit = $y_unit;
            }
            $width *= $units->{$x_unit}->{to_pt};
            $height *= $units->{$y_unit}->{to_pt};
            if (wantarray) {
                return (undef, $width, $height);
            }
            return {
                width => $width,
                height => $height
            };
        }
        return;
    }

    sub get_papersize {
        my ($self, $papersize) = @_;
        my $ph;
        my @cmd;
        if (defined $papersize) {
            @cmd = ("paperconf", "-p", $papersize, "-n", "-s");
        } else {
            @cmd = ("paperconf", "-n", "-s");
        }
        if (!open($ph, "-|", @cmd)) {
            die("exec paperconf: $!");
        }
        local $/ = undef;
        my $result = <$ph>;
        if (!close($ph)) {
            die("paperconf failed: $!");
        }
        $result =~ s{\A\s+}{};
        $result =~ s{\s+\z}{};
        my ($papersizename, $width, $height) = split(' ', $result);
        if (wantarray) {
            return ($papersizename, $width, $height);
        }
        return {
            papersize => $papersizename,
            width => $width,
            height => $height
        };
    }

    sub read_papersize {
        my ($self, $papersize) = @_;
        my ($x, $y) = $self->parse_custom_papersize($papersize);
        if (defined $x && defined $y) {
            if (wantarray) {
                return (undef, $x, $y);
            }
            return {
                width => $x,
                height => $y
            };
        }
        return $self->get_papersize($papersize);
    }

    sub generate_dot_grid_paper {
        my ($self, %args) = @_;

        my $width = $self->width;
        my $height = $self->height;

        my $left_margin = 0;
        my $right_margin = $width;

        my $bottom_margin = 0;
        my $top_margin = $height;

        my $x_origin = $width / 2;
        my $y_origin = $height / 2;

        my $x_spacing = $self->convert_to_pt("1/4in");
        my $y_spacing = $self->convert_to_pt("1/4in");

        my $left_margin_line = $self->convert_to_pt("1.25in");

        my @x_dot_points = $self->get_points(
            spacing => $x_spacing,
            min     => 0,
            max     => $width,
            origin  => $x_origin,
            nearest_margin_line => $left_margin_line
        );

        my @y_dot_points = $self->get_points(
            spacing => $y_spacing,
            min     => 0,
            max     => $height,
            origin  => $y_origin
        );

        my $real_left_margin_line = $self->point_nearest($left_margin_line, @x_dot_points);

        my $doc = $self->create_document;
        my $root = $self->root;

        my $style = $self->create_style_element;
        $root->appendChild($style);

        my $margin_lines     = $self->create_g_element("margin-lines");
        my $dots             = $self->create_g_element("dots");

        $root->appendChild($margin_lines);
        $root->appendChild($dots);

        foreach my $x (@x_dot_points) {
            foreach my $y (@y_dot_points) {
                my $line = $self->create_line(
                    x => $x, y => $y, class => "dot"
                );
                $dots->appendChild($line);
            }
        }

        my $mline = $self->create_line(
            x => $real_left_margin_line,
            y1 => $bottom_margin,
            y2 => $top_margin,
            class => "margin-line"
        );
        $margin_lines->appendChild($mline);

        print $doc->toString(1);
    }

    sub generate_line_dot_grid_paper {
        my ($self, %args) = @_;

        my $width = $self->width;
        my $height = $self->height;

        my $left_margin = 0;
        my $right_margin = $width;

        my $bottom_margin = 0;
        my $top_margin = $height;

        my $x_origin = $width / 2;
        my $y_origin = $height / 2;

        my $x_spacing = $self->convert_to_pt("5/16in");
        my $y_spacing = $self->convert_to_pt("5/16in");
        my $y_dot_spacing = $y_spacing / 4;

        my $left_margin_line = $self->convert_to_pt("1.25in");

        my $top_y_point    = $height - $self->convert_to_pt("1.5in");
        my $bottom_y_point = $self->convert_to_pt("1in");

        # Compute the points.

        my @x_points = $self->get_points(
            spacing => $x_spacing,
            min     => 0,
            max     => $width,
            origin  => $x_origin,
            nearest_margin_line => $left_margin_line
        );

        my @y_points = $self->get_points(
            spacing => $y_spacing,
            min     => 0,
            max     => $height,
            origin  => $y_origin,
            ends_nearest_margins => 1
        );

        my @y_dot_points = $self->get_points(
            spacing => $y_dot_spacing,
            min     => 0,
            max     => $height,
            origin  => $y_origin
        );

        my $real_left_margin_line = $self->point_nearest($left_margin_line, @x_points);

        my @x_dot_points = @x_points;

        # my $additional_dots_above = 3; # thin lines above for seyes/french ruling
        # my $additional_dots_below = 2; # thin lines below for seyes/french ruling

        my $real_top_y_point    = $self->point_nearest($top_y_point,    @y_points);
        my $real_bottom_y_point = $self->point_nearest($bottom_y_point, @y_points);

        @y_points     = grep { $_ <= $real_top_y_point    } @y_points;
        @y_points     = grep { $_ >= $real_bottom_y_point } @y_points;

        # @y_dot_points = grep { $_ <= $real_top_y_point    + ($additional_dots_above + 0.5) * $y_spacing / 4 } @y_dot_points;
        # @y_dot_points = grep { $_ >= $real_bottom_y_point - ($additional_dots_below + 0.5) * $y_spacing / 4 } @y_dot_points;

        @y_dot_points = exclude(@y_dot_points, @y_points);

        # Draw the paper.

        my $doc = $self->create_document;
        my $root = $self->root;

        my $style = $self->create_style_element;
        $root->appendChild($style);

        my $horizontal_lines = $self->create_g_element("horizontal-lines");
        my $vertical_lines   = $self->create_g_element("vertical-lines");
        my $margin_lines     = $self->create_g_element("margin-lines");
        my $dots             = $self->create_g_element("dots");

        $root->appendChild($horizontal_lines);
        $root->appendChild($vertical_lines);
        $root->appendChild($margin_lines);
        $root->appendChild($dots);

        foreach my $y (@y_points) {
            my $x1 = $left_margin;
            my $x2 = $right_margin;
            my $line = $self->create_line(
                x1 => $x1, x2 => $x2, y => $y,
                class => "line light"
            );
            $horizontal_lines->appendChild($line);
        }

        foreach my $x (@x_dot_points) {
            foreach my $y (@y_dot_points) {
                my $line = $self->create_line(
                    x => $x, y => $y, class => "dot light"
                );
                $dots->appendChild($line);
            }
        }

        my $mline = $self->create_line(
            x => $real_left_margin_line,
            y1 => $bottom_margin,
            y2 => $top_margin,
            class => "margin-line"
        );
        $margin_lines->appendChild($mline);

        print $doc->toString(1);
    }

    sub get_points {
        my ($self, %args) = @_;
        my $spacing = $args{spacing};
        my $origin  = $args{origin};
        my $min     = $args{min};
        my $max     = $args{max};
        my $ends_nearest_margins = delete $args{ends_nearest_margins};
        my $nearest_margin_line = delete $args{nearest_margin_line};

        if ($ends_nearest_margins) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $min1 = $points1[0];

            my $min2 = $points2[0];
            if ($min1 < $min2) {
                return @points1;
            }
            return @points2;
        }

        if ($nearest_margin_line) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $point1 = $self->point_nearest($nearest_margin_line, @points1);
            my $point2 = $self->point_nearest($nearest_margin_line, @points2);
            my $dist1 = abs($point1 - $nearest_margin_line);
            my $dist2 = abs($point2 - $nearest_margin_line);
            if ($dist1 < $dist2) {
                return @points1;
            }
            return @points2;
        }

        my @points = ($origin);
        $spacing = $self->convert_to_pt($spacing);
        my $x;
        for ($x = $origin + $spacing; $x <= $max; $x += $spacing) {
            push(@points, $x);
        }
        for ($x = $origin - $spacing; $x >= $min; $x -= $spacing) {
            unshift(@points, $x);
        }
        return @points;
    }


    sub point_nearest {
        my ($self, $x, @points) = @_;
        my @dist = map { abs($x - $_) } @points;
        my $mindist = min(@dist);
        for (my $i = 0; $i < scalar @points; $i += 1) {
            if ($mindist == $dist[$i]) {
                return $points[$i];
            }
        }
        return undef;           # should NEVER happen.
    }

    sub create_line {
        my ($self, %args) = @_;
        my $doc = $self->doc;
        my $line = $doc->createElement("line");
        my $x1 = $args{x1} // $args{x};
        my $x2 = $args{x2} // $args{x};
        my $y1 = $args{y1} // $args{y};
        my $y2 = $args{y2} // $args{y};
        $y1 = $self->height - $y1;
        $y2 = $self->height - $y2;
        $line->setAttribute("x1", $x1);
        $line->setAttribute("x2", $x2);
        $line->setAttribute("y1", $y1);
        $line->setAttribute("y2", $y2);
        $line->setAttribute("class", $args{class}) if defined $args{class};
        return $line;
    }

    sub create_document {
        my ($self) = @_;
        my $width = $self->width;
        my $height = $self->height;
        my $viewBox = sprintf("%f %f %f %f", 0, 0, $width, $height);
        my $doc = $self->doc(XML::LibXML::Document->new("1.0", "UTF-8"));
        my $root = $self->root($doc->createElement("svg"));
        $root->setAttribute("width", $width . "pt");
        $root->setAttribute("height", $height . "pt");
        $root->setAttribute("viewBox", $viewBox);
        $root->setAttribute("xmlns", "http://www.w3.org/2000/svg");
        $doc->setDocumentElement($root);
        return $doc;
    }

    # ff = 255
    # b3 = 179
    # 67 = 103
    # #b3b3ff => #6767ff
    # #b30000 => #670000
    sub create_style_element {
        my ($self, $css) = @_;
        my $light_line_stroke_width = $self->convert_to_pt("1/300in");
        my $line_stroke_width       = $self->convert_to_pt("2/300in");
        my $heavy_line_stroke_width = $self->convert_to_pt("3/300in");
        my $light_dot_stroke_width  = $self->convert_to_pt("4/300in");
        my $dot_stroke_width        = $self->convert_to_pt("6/300in");
        my $heavy_dot_stroke_width  = $self->convert_to_pt("9/300in");
        $css //= <<"EOF";
            .line {
                stroke: #6767ff;
                stroke-linecap: round;
                stroke-width: ${line_stroke_width}pt;
                opacity: 0.5;
            }
            .dot {
                stroke: #6767ff;
                stroke-linecap: round;
                stroke-width: ${dot_stroke_width}pt;
                opacity: 0.5;
            }
            .margin-line {
                stroke: #670000;
                stroke-linecap: round;
                stroke-width: ${line_stroke_width}pt;
                opacity: 0.5;
            }
            .line.light {
                stroke-width: ${light_line_stroke_width}pt;
            }
            .line.heavy {
                stroke-width: ${heavy_line_stroke_width}pt;
            }
            .dot.light {
                stroke-width: ${light_dot_stroke_width}pt;
            }
            .dot.heavy {
                stroke-width: ${heavy_dot_stroke_width}pt;
            }
            .margin-line.light {
                stroke-width: ${light_line_stroke_width}pt;
            }
            .margin-line.heavy {
                stroke-width: ${heavy_line_stroke_width}pt;
            }
EOF
        my $doc = $self->doc;
        my $style = $doc->createElement("style");
        $style->appendText($css);
        return $style;
    }

    sub create_g_element {
        my ($self, $id) = @_;
        my $doc = $self->doc;
        my $g = $doc->createElement("g");
        $g->setAttribute("id", $id);
        return $g;
    }
};

package My::Printable::Util {
    use base "Exporter";

    our @EXPORT_OK;
    BEGIN {
        push(@EXPORT_OK, 'exclude');
    }

    use Data::Dumper;

    sub exclude(\@@);
    sub exclude(\@@) {
        my ($a, @b) = @_;
        my %b = map { ($_, 1) } @b;
        return grep { !$b{$_} } @$a;
    }
}
