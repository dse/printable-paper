#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

# on Cygwin:
#     apt-cyg install libpaper1 libpaper-bin
# on other systems:
#     it's part of something called libpaper.
#     git@github.com:naota/libpaper.git
# to list all paper sizes and their widths and heights:
#     paperconf -a -n -s
# to get the default paper size:
#     paperconf

our $opt_papersize;
our $opt_width;
our $opt_height;
our $opt_unit_modifier;
our $opt_color_modifier;
our @opt_modifiers;

use Getopt::Long;
use Data::Dumper;
use Carp::Always;

Getopt::Long::Configure(qw(bundling gnu_compat no_ignore_case));
Getopt::Long::GetOptions(
    "M|p|media|paper|paper-size=s"    => \$opt_papersize,
    "w|width=s"                       => \$opt_width,
    "h|height=s"                      => \$opt_height,
    "g|gray|grey|grayscale|greyscale" => sub { $opt_color_modifier = "grayscale"; },
    "c|color|colour"                  => sub { $opt_color_modifier = "color";     },
    "m|metric"                        => sub { $opt_unit_modifier = "metric";     },
    "i|imperial"                      => sub { $opt_unit_modifier = "imperial";   },
    "modifier=s"                      => sub { push(@opt_modifiers, $_[1]); },
    "help|?" => sub {
        usage();
        exit(0);
    }
) or die("Type '$0 --help' for help.\n");

sub usage { print <<"EOF"; }
usage:
    $0 [<option> ...]
options:
    -M, -p, --media, --paper, --paper-size=<paper-size-name>|<custom-paper-size>
        Specify paper size (run paperconf -a -n -s to list paper sizes)
    -w, --width=<width>
    -h, --height=<height>
    -?, --help
<width> or <height>:
    <number> [<unit>]           <unit> defaults to pt
    <number>/<number> [<unit>]
<custom-paper-size>:
    <width> *|x <height>        height <unit> defaults to pt;
                                width <unit> defaults to same <unit> as height
examples:
    --width=8.5in       --paper-size='8.5in x 11in'     --paper-size=letter
    --width=612         --paper-size='612*792'
    --height=297mm      --paper-size='210.224x297.302mm'
EOF

my $p = My::Printable->new();
$p->set_papersize($opt_papersize) if defined $opt_papersize;
$p->set_width($opt_width)         if defined $opt_width;
$p->set_height($opt_height)       if defined $opt_height;
$p->set_modifiers($opt_unit_modifier, $opt_color_modifier, @opt_modifiers);

if (!scalar @ARGV) {
    die("No paper ruling argument specified.\n");
}

foreach my $arg (@ARGV) {
    $p->generate_paper($arg);
}

package My::Printable {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;

    INIT {
        public papersize, default => "letter";
        public width,     default => 612;
        public height,    default => 792;

        public doc;
        public root;

        public canvas;
        public ruling;
        public left_margin;
        public right_margin;
        public bottom_margin;
        public top_margin;
        public x_origin;
        public y_origin;

        public unit;
        public unit_x;
        public unit_y;

        public modifiers;
    }

    sub init {
        my ($self) = @_;
        $self->unit(My::Printable::Unit->new);
        $self->unit_x(My::Printable::Unit->new);
        $self->unit_y(My::Printable::Unit->new);
    }

    use XML::LibXML;
    use List::Util qw(min max);
    use Data::Dumper;

    # use My::Printable::Util qw(exclude);
    sub exclude(\@@);      # for embedded package subs with prototypes
    INIT {
        import My::Printable::Util qw(exclude);
    }

    our $RULINGS;
    BEGIN {
        $RULINGS = {
            dot_grid => {
                unit => {
                    DEFAULT => "1/4in",
                    "1/5in" => "1/5in",
                    "5mm" => "5mm",
                    "6mm" => "6mm",
                },
                dot_grid => {
                    x_spacing => "1unit",
                    y_spacing => "1unit",
                    class => {
                        DEFAULT => "blue dot",
                        grayscale => "gray dot",
                    },
                    x_coordinates_nearest_margins => 1,
                    y_coordinates_nearest_margins => 1,
                },
                left_margin_line => {
                    x => {
                        DEFAULT => "1.25in",
                        metric => "41mm",
                    },
                    nearest => "dot-grid",
                    class => {
                        DEFAULT => "red margin-line",
                        grayscale => "gray margin-line",
                    },
                },
            },
            line_dot_grid => {
                unit => {
                    DEFAULT => "5/16in",
                    metric => "8mm",
                    "8mm" => "8mm",
                    "10mm" => "10mm",
                },
                dot_grid => {
                    x_spacing => "1unit",
                    y_spacing => "1/4unit",
                    class => "thin blue dot",
                },
                horizontal_lines => {
                    y_spacing => "1unit",
                    nearest_margins => 1,
                    bottom => {
                        DEFAULT => "1in",
                        metric => "28mm",
                    },
                    top => {
                        DEFAULT => "1.5in",
                        metric => "37mm",
                    },
                    class => {
                        DEFAULT => "thin blue line",
                        grayscale => "thin gray line",
                    },
                },
                left_margin_line => {
                    x => {
                        DEFAULT => "1.25in",
                        metric => "41mm",
                    },
                    nearest => "dot-grid",
                    class => {
                        DEFAULT => "red margin-line",
                        grayscale => "gray margin-line",
                    },
                },
            },
            seyes => {
                unit => {
                    DEFAULT => "5/16in",
                    metric => "8mm",
                    "8mm" => "8mm",
                    "10mm" => "10mm",
                },
                horizontal_lines => {
                    y_spacing => "1unit",
                    bottom => {
                        DEFAULT => "1in",
                        metric => "28mm",
                    },
                    top => {
                        DEFAULT => "1.5in",
                        metric => "37mm",
                    },
                    class => {
                        DEFAULT => "blue line",
                        grayscale => "gray line",
                    },
                    minor => {
                        every => 4,
                        extra => {
                            bottom => 2,
                            top => 3,
                        },
                        class => {
                            DEFAULT => {
                                DEFAULT => "thin blue line",
                                grayscale => "thin gray line",
                            },
                            "thinner-grid-lines" => {
                                DEFAULT => "super-thin blue line",
                                grayscale => "super-thin gray line",
                            },
                        },
                    },
                },
                vertical_lines => {
                    x_spacing => "1unit",
                    nearest_margins => 1,
                    class => {
                        DEFAULT => "thin blue line",
                        grayscale => "thin gray line",
                    },
                    left => {
                        DEFAULT => "1.25in",
                        metric => "41mm",
                    },
                },
                left_margin_line => {
                    x => {
                        DEFAULT => "1.25in",
                        metric => "41mm",
                    },
                    nearest => "vertical-lines",
                    class => {
                        DEFAULT => "red margin-line",
                        grayscale => "gray margin-line",
                    },
                },
            },
        };
    }

    sub set_papersize {
        my ($self, $spec) = @_;
        my ($name, $width, $height, $type) = My::Printable::PaperSizes->parse($spec);
        $self->papersize($name);
        $self->width($width);
        $self->height($height);
        $self->unit_x->set_percentage_basis($width);
        $self->unit_y->set_percentage_basis($height);
    }

    sub set_width {
        my ($self, $value, $unit) = @_;
        my ($pt, $type) = $self->unit->pt($value, $unit);
        $self->width($pt);
        $self->papersize(undef);
        $self->unit_x->set_percentage_basis($pt);
    }

    sub set_height {
        my ($self, $value, $unit) = @_;
        my ($pt, $type) = $self->unit->pt($value, $unit);
        $self->height($pt);
        $self->papersize(undef);
        $self->unit_y->set_percentage_basis($pt);
    }

    sub set_modifiers {
        my ($self, @modifiers) = @_;
        @modifiers = grep { defined $_ } @modifiers;
        $self->modifiers(\@modifiers);
    }

    sub generate_paper {
        my ($self, $ruling_name, %args) = @_;

        $ruling_name =~ s{-}{_}g;

        my $ruling = $RULINGS->{$ruling_name};
        if (!$ruling) {
            die("No such ruling: $ruling_name\n");
        }

        $self->unit->delete_unit("unit");
        $self->unit_x->delete_unit("unit");
        $self->unit_y->delete_unit("unit");
        my $ruling_unit = $self->value($ruling->{unit});
        if (defined $ruling_unit) {
            my $unit_pt = $self->unit->pt($ruling_unit);
            $self->unit->add_unit("unit", $unit_pt);
            $self->unit_x->add_unit("unit", $unit_pt);
            $self->unit_y->add_unit("unit", $unit_pt);
        }

        my $width  = $self->width;
        my $height = $self->height;

        my $left_margin  = $self->unit_x->pt($self->value($ruling->{left_margin}) // 0);
        my $right_margin = $self->width - $self->unit_x->pt($self->value($ruling->{right_margin}) // 0);

        my $bottom_margin = $self->unit_y->pt($self->value($ruling->{bottom_margin}) // 0);
        my $top_margin    = $self->height - $self->unit_y->pt($self->value($ruling->{top_margin}) // 0);

        my $x_origin = $self->unit_x->pt($self->value($ruling->{x_origin}) // "50%");
        my $y_origin = $self->unit_y->pt($self->value($ruling->{y_origin}) // "50%");

        $self->left_margin($left_margin);
        $self->right_margin($right_margin);
        $self->bottom_margin($bottom_margin);
        $self->top_margin($top_margin);
        $self->x_origin($x_origin);
        $self->y_origin($y_origin);

        my $doc = $self->create_document;
        my $root = $self->root;

        my $style = $self->create_style_element;
        $root->appendChild($style);

        $self->ruling($ruling);

        my $canvas = $self->canvas({});
        $canvas->{dot_grid}         = {};
        $canvas->{horizontal_lines} = {};
        $canvas->{vertical_lines}   = {};
        $canvas->{margin_lines}     = {};

        # Compute points
        $self->compute_dot_grid;
        $self->compute_horizontal_lines;
        $self->compute_vertical_lines;
        $self->compute_margin_lines;
        $self->chop_horizontal_lines;
        $self->compute_minor_horizontal_lines;
        $self->chop_vertical_lines;
        $self->relocate_margin_lines;
        $self->filter_grid_points;

        # Draw everything.
        $self->draw_dot_grid;
        $self->draw_minor_horizontal_lines;
        $self->draw_vertical_lines;
        $self->draw_horizontal_lines;
        $self->draw_margin_lines;

        print $doc->toString(1);
    }

    sub compute_dot_grid {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        if ($ruling->{dot_grid}) {
            my $x_coordinates_nearest_margins = $ruling->{dot_grid}->{x_coordinates_nearest_margins};
            my $y_coordinates_nearest_margins = $ruling->{dot_grid}->{y_coordinates_nearest_margins};
            my $x_spacing = $canvas_dot_grid->{x_spacing} = $self->unit_x->pt($self->value($ruling->{dot_grid}->{x_spacing}));
            my $y_spacing = $canvas_dot_grid->{y_spacing} = $self->unit_y->pt($self->value($ruling->{dot_grid}->{y_spacing}));
            $canvas_dot_grid->{x} = $self->get_points(
                spacing => $x_spacing,
                min => $self->left_margin,
                max => $self->right_margin,
                origin => $self->x_origin,
                nearest_margins => $x_coordinates_nearest_margins,
            );
            $canvas_dot_grid->{y} = $self->get_points(
                spacing => $y_spacing,
                min => $self->bottom_margin,
                max => $self->top_margin,
                origin => $self->y_origin,
                nearest_margins => $y_coordinates_nearest_margins,
            );
        }
    }

    sub compute_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        if ($ruling->{horizontal_lines}) {
            my $y_spacing = $canvas_horizontal_lines->{y_spacing} = $self->unit_y->pt($self->value($ruling->{horizontal_lines}->{y_spacing}));
            my $our_y_origin = $self->y_origin;
            if ($ruling->{dot_grid}) {
                $our_y_origin = $canvas_dot_grid->{y}->[0];
            }
            $canvas_horizontal_lines->{y} = $self->get_points(
                spacing => $y_spacing,
                min => $self->bottom_margin,
                max => $self->top_margin,
                origin => $our_y_origin,
                nearest_margins => $ruling->{horizontal_lines}->{nearest_margins},
            );
        }
    }

    sub compute_vertical_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        if ($ruling->{vertical_lines}) {
            my $x_spacing = $canvas_vertical_lines->{x_spacing} = $self->unit_x->pt($self->value($ruling->{vertical_lines}->{x_spacing}));
            my $our_x_origin = $self->x_origin;
            if ($ruling->{dot_grid}) {
                $our_x_origin = $canvas_dot_grid->{x}->[0];
            }
            $canvas_vertical_lines->{x} = $self->get_points(
                spacing => $x_spacing,
                min => $self->left_margin,
                max => $self->right_margin,
                origin => $our_x_origin,
                nearest_margins => $ruling->{vertical_lines}->{nearest_margins},
            );
        }
    }

    sub compute_margin_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_margin_lines = $self->canvas->{margin_lines};
        if ($ruling->{left_margin_line}) {
            $canvas_margin_lines->{left}->{x} = $self->unit_x->pt($self->value($ruling->{left_margin_line}->{x}));
        }
    }

    sub chop_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        my $height = $self->height;
        if ($ruling->{horizontal_lines}) {
            my $y = $canvas_horizontal_lines->{y};

            my $bottom = $self->value($ruling->{horizontal_lines}->{bottom});
            if (defined $bottom) {
                my $bottom_y = $self->unit_y->pt($bottom);
                $bottom_y = $self->point_nearest($bottom_y, @$y);
                @$y = grep { $_ >= $bottom_y } @$y;
            }

            my $top = $self->value($ruling->{horizontal_lines}->{top});
            if (defined $top) {
                my $top_y = $height - $self->unit_y->pt($top);
                $top_y = $self->point_nearest($top_y, @$y);
                @$y = grep { $_ <= $top_y } @$y;
            }
        }
    }

    sub chop_vertical_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        my $width = $self->width;
        if ($ruling->{vertical_lines}) {
            my $x = $canvas_vertical_lines->{x};

            my $left = $self->value($ruling->{vertical_lines}->{left});
            if (defined $left) {
                my $left_x = $self->unit_x->pt($left);
                $left_x = $self->point_nearest($left_x, @$x);
                @$x = grep { $_ >= $left_x } @$x;
            }

            my $right = $self->value($ruling->{vertical_lines}->{right});
            if (defined $right) {
                my $right_x = $width - $self->unit_x->pt($right);
                $right_x = $self->point_nearest($right_x, @$x);
                @$x = grep { $_ <= $right_x } @$x;
            }
        }
    }

    sub compute_minor_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        if ($ruling->{horizontal_lines}) {
            my $minor = $ruling->{horizontal_lines}->{minor};
            if (defined $minor) {
                my $y = $canvas_horizontal_lines->{y};
                my $every = $self->value($minor->{every});
                my $extra = $self->value($minor->{extra});
                my $extra_bottom = ($extra && $self->value($extra->{bottom})) // 0;
                my $extra_top    = ($extra && $self->value($extra->{top}))    // 0;
                my $y_bottom = min @$y;
                my $y_top    = max @$y;
                my $y_spacing = $canvas_horizontal_lines->{y_spacing} / $every;
                my $new_y_bottom = $y_bottom - ($extra_bottom + 0.5) * $y_spacing;
                my $new_y_top    = $y_top    + ($extra_top    + 0.5) * $y_spacing;
                my $minor_y = $canvas_horizontal_lines->{minor}->{y} = $self->get_points(
                    spacing => $y_spacing,
                    min => $new_y_bottom,
                    max => $new_y_top,
                    origin => $y_bottom
                );
                @$minor_y = exclude(@$minor_y, @{$canvas_horizontal_lines->{y}});
            }
        }
    }

    sub relocate_margin_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_margin_lines = $self->canvas->{margin_lines};
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        if ($ruling->{left_margin_line}) {
            my $nearest = $self->value($ruling->{left_margin_line}->{nearest});
            if (defined $nearest) {
                if ($nearest eq "dot-grid" && $ruling->{dot_grid}) {
                    $canvas_margin_lines->{left}->{x} = $self->point_nearest($canvas_margin_lines->{left}->{x},
                                                                             @{$canvas_dot_grid->{x}});
                }
                if ($nearest eq "vertical-lines" && $ruling->{vertical_lines}) {
                    $canvas_margin_lines->{left}->{x} = $self->point_nearest($canvas_margin_lines->{left}->{x},
                                                                             @{$canvas_vertical_lines->{x}});
                }
            }
        }
    }

    sub filter_grid_points {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_margin_lines = $self->canvas->{margin_lines};
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        if ($ruling->{dot_grid}) {
            my $x = $canvas_dot_grid->{x};
            my $y = $canvas_dot_grid->{y};
            if ($ruling->{horizontal_lines}) {
                @$y = exclude(@$y, @{$canvas_horizontal_lines->{y}});
            }
            if ($ruling->{horizontal_lines}->{minor}) {
                @$y = exclude(@$y, @{$canvas_horizontal_lines->{minor}->{y}});
            }
            if ($ruling->{vertical_lines}) {
                @$x = exclude(@$x, @{$canvas_vertical_lines->{x}});
            }
            if ($ruling->{left_margin_line}) {
                @$x = exclude(@$x, ($canvas_margin_lines->{left}->{x}));
            }
        }
    }

    sub draw_dot_grid {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        if ($ruling->{dot_grid}) {
            my $layer = $self->layer("dot-grid");
            foreach my $x (@{$canvas_dot_grid->{x}}) {
                foreach my $y (@{$canvas_dot_grid->{y}}) {
                    my $line = $self->create_line(
                        x => $x, y => $y,
                        class => $self->value($ruling->{dot_grid}->{class}) // "thin blue dot"
                    );
                    $layer->appendChild($line);
                }
            }
        }
    }

    sub draw_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        if ($ruling->{horizontal_lines}) {
            my $layer = $self->layer("horizontal-lines");
            foreach my $y (@{$canvas_horizontal_lines->{y}}) {
                my $x1 = $self->left_margin;
                my $x2 = $self->right_margin;
                my $line = $self->create_line(
                    x1 => $x1, x2 => $x2, y => $y,
                    class => $self->value($ruling->{horizontal_lines}->{class}) // "thin blue line"
                );
                $layer->appendChild($line);
            }
        }
    }

    sub draw_minor_horizontal_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        if ($ruling->{horizontal_lines} && $ruling->{horizontal_lines}->{minor}) {
            my $layer = $self->layer("minor-horizontal-lines");
            my $minor = $canvas_horizontal_lines->{minor};
            if (defined $minor) {
                foreach my $y (@{$minor->{y}}) {
                    my $x1 = $self->left_margin;
                    my $x2 = $self->right_margin;
                    my $line = $self->create_line(
                        x1 => $x1, x2 => $x2, y => $y,
                        class => $self->value($ruling->{horizontal_lines}->{minor}->{class}) // "super-thin blue line"
                    );
                    $layer->appendChild($line);
                }
            }
        }
    }

    sub draw_vertical_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        if ($ruling->{vertical_lines}) {
            my $layer = $self->layer("vertical-lines");
            foreach my $x (@{$canvas_vertical_lines->{x}}) {
                my $y1 = $self->bottom_margin;
                my $y2 = $self->top_margin;
                my $line = $self->create_line(
                    y1 => $y1, y2 => $y2, x => $x,
                    class => $self->value($ruling->{vertical_lines}->{class}) // "thin blue line"
                );
                $layer->appendChild($line);
            }
        }
    }

    sub draw_margin_lines {
        my ($self) = @_;
        my $ruling = $self->ruling;
        my $canvas_margin_lines = $self->canvas->{margin_lines};
        if ($ruling->{left_margin_line}) {
            my $layer = $self->layer("margin-lines");
            my $margin_line = $self->create_line(
                x => $canvas_margin_lines->{left}->{x},
                y1 => $self->bottom_margin,
                y2 => $self->top_margin,
                class => $self->value($ruling->{left_margin_line}->{class}) // "red margin-line"
            );
            $layer->appendChild($margin_line);
        }
    }

    sub get_points {
        my ($self, %args) = @_;
        my $spacing = $args{spacing};
        my $origin  = $args{origin};
        my $min     = $args{min};
        my $max     = $args{max};
        my $nearest_margins = delete $args{nearest_margins};
        my $nearest_margin_line = delete $args{nearest_margin_line};

        if ($nearest_margins) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $min1 = $points1[0];

            my $min2 = $points2[0];
            if ($min1 < $min2) {
                return @points1 if wantarray;
                return \@points1;
            }
            return @points2 if wantarray;
            return \@points2;
        }

        if ($nearest_margin_line) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $point1 = $self->point_nearest($nearest_margin_line, @points1);
            my $point2 = $self->point_nearest($nearest_margin_line, @points2);
            my $dist1 = abs($point1 - $nearest_margin_line);
            my $dist2 = abs($point2 - $nearest_margin_line);
            if ($dist1 < $dist2) {
                return @points1 if wantarray;
                return \@points1;
            }
            return @points2 if wantarray;
            return \@points2;
        }

        my @points = ($origin);
        $spacing = $self->unit->pt($spacing);
        my $x;
        for ($x = $origin + $spacing; $x <= $max; $x += $spacing) {
            push(@points, $x);
        }
        for ($x = $origin - $spacing; $x >= $min; $x -= $spacing) {
            unshift(@points, $x);
        }
        return @points if wantarray;
        return \@points;
    }


    sub point_nearest {
        my ($self, $x, @points) = @_;
        my @dist = map { abs($x - $_) } @points;
        my $mindist = min(@dist);
        for (my $i = 0; $i < scalar @points; $i += 1) {
            if ($mindist == $dist[$i]) {
                return $points[$i];
            }
        }
        return undef;           # should NEVER happen.
    }

    sub create_line {
        my ($self, %args) = @_;
        my $doc = $self->doc;
        my $line = $doc->createElement("line");
        my $x1 = $args{x1} // $args{x};
        my $x2 = $args{x2} // $args{x};
        my $y1 = $args{y1} // $args{y};
        my $y2 = $args{y2} // $args{y};
        $y1 = $self->height - $y1;
        $y2 = $self->height - $y2;
        $line->setAttribute("x1", $x1);
        $line->setAttribute("x2", $x2);
        $line->setAttribute("y1", $y1);
        $line->setAttribute("y2", $y2);
        $line->setAttribute("class", $args{class}) if defined $args{class};
        return $line;
    }

    sub create_document {
        my ($self) = @_;
        my $width = $self->width;
        my $height = $self->height;
        my $viewBox = sprintf("%f %f %f %f", 0, 0, $width, $height);
        my $doc = $self->doc(XML::LibXML::Document->new("1.0", "UTF-8"));
        my $root = $self->root($doc->createElement("svg"));
        $root->setAttribute("width", $width . "pt");
        $root->setAttribute("height", $height . "pt");
        $root->setAttribute("viewBox", $viewBox);
        $root->setAttribute("xmlns", "http://www.w3.org/2000/svg");
        $doc->setDocumentElement($root);
        return $doc;
    }

    sub create_style_element {
        my ($self, $css) = @_;

        my $super_thin_line_stroke_width = $self->unit->pt("3/600in");
        my $thin_line_stroke_width       = $self->unit->pt("4/600in");
        my $line_stroke_width            = $self->unit->pt("6/600in");
        my $thick_line_stroke_width      = $self->unit->pt("9/600in");

        my $thin_dot_stroke_width        = $self->unit->pt("4/300in");
        my $dot_stroke_width             = $self->unit->pt("6/300in");
        my $thick_dot_stroke_width       = $self->unit->pt("9/300in");

        $css //= <<"EOF";
            .line, .dot { stroke-linecap: round; }

            .line            { stroke-width: ${line_stroke_width}pt; }
            .line.super-thin { stroke-width: ${super_thin_line_stroke_width}pt; }
            .line.thin       { stroke-width: ${thin_line_stroke_width}pt; }
            .line.thick      { stroke-width: ${thick_line_stroke_width}pt; }

            .dot       { stroke-width: ${dot_stroke_width}pt; }
            .dot.thin  { stroke-width: ${thin_dot_stroke_width}pt; }
            .dot.thick { stroke-width: ${thick_dot_stroke_width}pt; }

            .blue  { stroke: #b3b3ff; }
            .red   { stroke: #ff9999; }
            .green { stroke: #b3ffb3; }
            .gray  { stroke: #b3b3b3; }

            .light.blue  { stroke: #d9d9ff; }
            .light.red   { stroke: #ffcccc; }
            .light.green { stroke: #d9ffd9; }
            .light.gray  { stroke: #d9d9d9; }

            .dark.blue  { stroke: #6767ff; }
            .dark.red   { stroke: #ff3333; }
            .dark.green { stroke: #67ff67; }
            .dark.gray  { stroke: #676767; }

            .alternate-blue  { stroke: #6767ff; opacity: 0.5; }
            .alternate-red   { stroke: #ff3333; opacity: 0.5; }
            .alternate-green { stroke: #67ff67; opacity: 0.5; }
            .alternate-gray  { stroke: #676767; opacity: 0.5; }
EOF
        my $doc = $self->doc;
        my $style = $doc->createElement("style");
        $style->appendText($css);
        return $style;
    }

    sub create_g_element {
        my ($self, $id) = @_;
        my $doc = $self->doc;
        my $g = $doc->createElement("g");
        $g->setAttribute("id", $id);
        return $g;
    }

    sub layer {
        my ($self, $id) = @_;
        my $doc = $self->doc;
        my $root = $self->root;
        my ($layer) = $doc->findnodes("//*[\@id='" . $id . "']");
        if ($layer) {
            return $layer;
        }
        $layer = $self->create_g_element($id);
        $root->appendChild($layer);
        return $layer;
    }

    sub value {
        my ($self, $value) = @_;
        return $value if ref $value ne "HASH";
        return $value if !exists $value->{DEFAULT};
        my $valuehash = $value;
        $value = $valuehash->{DEFAULT};
        foreach my $modifier (@{$self->modifiers}) {
            if (exists $valuehash->{$modifier}) {
                $value = $valuehash->{$modifier};
            }
        }
        return $self->value($value);
    }
};

package My::Printable::Unit {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;

    our $UNITS;
    BEGIN {
        $UNITS = {
            "pt" => {
                to_pt => 1,
                type => "imperial",
            },
            "pc" => {
                to_pt => 12,    # 1 pc = 12 pt
                type => "imperial",
            },
            "in" => {
                to_pt => 72,    # 1 in = 72 pt
                type => "imperial",
            },
            "cm" => {
                to_pt => (72 / 2.54), # 1 cm ~= 28.3465 pt
                type => "metric",
            },
            "mm" => {
                to_pt => (72 / 25.4), # 1 cm ~= 2.83465 pt
                type => "metric",
            },
            "px" => {
                to_pt => (72 / 96), # 1 px = 0.75 pt
                type => "imperial"
            },
            "pd" => {           # pixel dots
                to_pt => (72 / 300), # 1 pd = 1 dot on a 300dpi laser printer = 1/300 in = 72/300 pt
                type => "imperial"
            }
        };
    }

    sub init {
        my ($self) = @_;
        $self->{units} = { %$UNITS }; # shallow copy
    }

    sub set_percentage_basis {
        my ($self, $value, $unit) = @_;
        delete $self->{units}->{'%'};
        $self->add_unit('%', $value / 100, $unit);
    }

    sub add_unit {
        my ($self, $unit, $value, $value_unit) = @_;
        die("Unit already defined: $unit\n") if exists $self->{units}->{$unit};
        my ($pt, $type) = $self->pt($value, $value_unit);
        $self->{units}->{$unit} = {
            to_pt => $pt,
            type => $type
        };
    }

    sub delete_unit {
        my ($self, $unit) = @_;
        delete $self->{units}->{$unit};
    }

    sub rx_units {
        my ($self) = @_;
        $self = object($self);

        my @units = sort keys %{$self->{units}};
        my $units = join('|', map { quotemeta($_) } @units);
        return qr{$units}xi;
    }

    sub rx_number {
        my ($self) = @_;
        $self = object($self);

        return qr{\d+(?:\.\d*)?|\.\d+}ix;
    }

    sub pt {
        my ($self, $value, $unit) = @_;
        $self = object($self);

        my ($numerator, $denominator);

        my $rx_units  = $self->rx_units;
        my $rx_number = $self->rx_number;
        my $spec;

        if (defined $unit) {
            $spec = "$value $unit";
            if ($value =~ m{\A
                            \s*
                            ($rx_number)
                            (?:
                                \s*
                                /
                                \s*
                                ($rx_number)
                            )?
                            \s*
                            \z}xi) {
                ($numerator, $denominator) = ($1, $2);
            } else {
                die("Invalid size specification: $value $unit\n");
            }
        } else {
            $spec = "$value";
            if ($value =~ m{\A
                            \s*
                            ($rx_number)
                            (?:
                                \s*
                                /
                                \s*
                                ($rx_number)
                            )?
                            \s*
                            ($rx_units)?
                            \s*
                            \z}xi) {
                ($numerator, $denominator, $unit) = ($1, $2, $3);
            } else {
                die("Invalid size specification: $spec\n");
            }
        }

        my $number;
        if (defined $denominator) {
            $number = $numerator / $denominator;
        } else {
            $number = $numerator;
        }

        if (!defined $unit || $unit eq "") {
            return ($number, "imperial") if wantarray;
            return $number;
        }

        my $unit_info = $self->{units}->{$unit};
        if (!defined $unit_info) {
            die("Invalid size specification: $spec\n");
        }

        my $result_pt   = $number * $unit_info->{to_pt};
        my $result_type = $unit_info->{type};

        return ($result_pt, $result_type) if wantarray;
        return $result_pt;
    }

    our $SINGLETON;

    sub object {
        my ($self) = @_;
        if (!ref $self) {
            $self = ($SINGLETON //= __PACKAGE__->new);
        }
        return $self;
    }
};

package My::Printable::PaperSizes {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;

    use POSIX qw(round);

    our $SIZES;
    INIT {
        $SIZES = {
            letter => {
                width  => scalar(My::Printable::Unit->pt(8.5, "in")),
                height => scalar(My::Printable::Unit->pt(11, "in")),
                type   => "imperial",
            },
            a4 => {
                width  => scalar(My::Printable::Unit->pt(250 / sqrt(sqrt(2)), "mm")),
                height => scalar(My::Printable::Unit->pt(250 * sqrt(sqrt(2)), "mm")),
                type   => "metric",
            },
        };
    }

    sub parse {
        my ($self, $spec) = @_;
        $spec = lc $spec;

        my $result =
            $self->parse_builtin_papersize($spec) //
            $self->parse_custom_papersize($spec) //
            $self->parse_paperconf_papersize($spec);
        if (wantarray) {
            return ($result->{name},
                    $result->{width},
                    $result->{height},
                    $result->{type});
        }
        return $result;
    }

    sub parse_builtin_papersize {
        my ($self, $spec) = @_;
        $spec = lc $spec;

        my $info = $SIZES->{spec};
        return if !$info;

        $info = { %$info };     # shallow copy
        $info->{name} //= $spec;
        return $info;
    }

    sub parse_paperconf_papersize {
        my ($self, $spec) = @_;
        $spec = lc $spec;

        my $ph;
        my @cmd;
        if (defined $spec) {
            @cmd = ("paperconf", "-p", $spec, "-n", "-s");
        } else {
            @cmd = ("paperconf", "-n", "-s");
        }
        if (!open($ph, "-|", @cmd)) {
            warn("exec paperconf: $!");
            return;
        }
        local $/ = undef;
        my $result = <$ph>;
        if (!close($ph)) {
            warn("paperconf failed: $!");
            return;
        }
        $result =~ s{\A\s+}{};
        $result =~ s{\s+\z}{};

        my ($name, $width, $height) = split(' ', $result);
        my $type;
        if ($width == round($width) && $height == round($height)) {
            $type = "imperial";
        } else {
            $type = "metric";
        }

        return {
            name => $name,
            width => $width,
            height => $height,
            type   => $type
        };
    }

    sub parse_custom_papersize {
        my ($self, $spec) = @_;
        $spec = lc $spec;

        my $rx_number = My::Printable::Unit->rx_number;
        my $rx_units  = My::Printable::Unit->rx_units;

        if ($spec =~ m{\A
                       \s*
                       ($rx_number)
                       (?:
                           \s*
                           /
                           \s*
                           ($rx_number)
                       )?
                       \s*
                       ($rx_units)?
                       \s*
                       (?:\*|x)
                       \s*
                       ($rx_number)
                       (?:
                           \s*
                           /
                           \s*
                           ($rx_number)
                       )?
                       \s*
                       ($rx_units)?
                       \s*
                       \z}xi) {
            my ($width, $width_denominator, $x_unit,
                $height, $height_denominator, $y_unit) = ($1, $2, $3, $4, $5, $6);

            $width  /= $width_denominator  if defined $width_denominator;
            $height /= $height_denominator if defined $height_denominator;

            if (!defined $y_unit || $y_unit eq "") {
                $y_unit = "pt";
            }
            if (!defined $x_unit || $x_unit eq "") {
                $x_unit = $y_unit;
            }

            my $x_type;
            my $y_type;
            ($width,  $x_type) = My::Printable::Unit->pt($width,  $x_unit);
            ($height, $y_type) = My::Printable::Unit->pt($height, $y_unit);

            my $type = $x_type // $y_type;
            if (wantarray) {
                return (undef, $width, $height, $type);
            }
            return {
                width  => $width,
                height => $height,
                type   => $type
            };
        }
        return;
    }

    our $SINGLETON;

    sub object {
        my ($self) = @_;
        if (!ref $self) {
            $self = ($SINGLETON //= __PACKAGE__->new);
        }
        return $self;
    }
};

package My::Printable::Util {
    use base "Exporter";

    our @EXPORT_OK;
    BEGIN {
        push(@EXPORT_OK, 'exclude');
    }

    use Data::Dumper;

    sub exclude(\@@);
    sub exclude(\@@) {
        my ($a, @b) = @_;
        my %b = map { ($_, 1) } @b;
        return grep { !$b{$_} } @$a;
    }
};
