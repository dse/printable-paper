#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

# on Cygwin:
#     apt-cyg install libpaper1 libpaper-bin
# on other systems:
#     it's part of something called libpaper.
#     git@github.com:naota/libpaper.git
# to list all paper sizes and their widths and heights:
#     paperconf -a -n -s
# to get the default paper size:
#     paperconf

our $opt_papersize;
our $opt_width;
our $opt_height;
our $opt_unit_type;
our $opt_color_type;
our @opt_modifiers;
our $opt_output_yaml;
our $opt_output_json;
our $opt_output_perl;

use Getopt::Long;
use Data::Dumper;
use Carp::Always;

Getopt::Long::Configure(qw(bundling gnu_compat no_ignore_case));
Getopt::Long::GetOptions(
    "M|p|media|paper|paper-size=s"    => \$opt_papersize,
    "w|width=s"                       => \$opt_width,
    "h|height=s"                      => \$opt_height,
    "g|gray|grey|grayscale|greyscale" => sub { $opt_color_type = "grayscale"; },
    "c|color|colour"                  => sub { $opt_color_type = "color";     },
    "m|metric"                        => sub { $opt_unit_type = "metric";     },
    "i|imperial"                      => sub { $opt_unit_type = "imperial";   },
    "modifier=s"                      => sub { push(@opt_modifiers, $_[1]); },
    "output-yaml"                     => \$opt_output_yaml,
    "output-json"                     => \$opt_output_json,
    "output-perl"                     => \$opt_output_perl,
    "help|?" => sub {
        usage();
        exit(0);
    }
) or die("Type '$0 --help' for help.\n");

sub usage { print <<"EOF"; }
usage:
    $0 [<option> ...]
options:
    -M, -p, --media, --paper, --paper-size=<paper-size-name>|<custom-paper-size>
        Specify paper size (run paperconf -a -n -s to list paper sizes)
    -w, --width=<width>
    -h, --height=<height>
    -?, --help
<width> or <height>:
    <number> [<unit>]           <unit> defaults to pt
    <number>/<number> [<unit>]
<custom-paper-size>:
    <width> *|x <height>        height <unit> defaults to pt;
                                width <unit> defaults to same <unit> as height
examples:
    --width=8.5in       --paper-size='8.5in x 11in'     --paper-size=letter
    --width=612         --paper-size='612*792'
    --height=297mm      --paper-size='210.224x297.302mm'
EOF

my $p = My::Printable->new();
if ($opt_output_yaml || $opt_output_json || $opt_output_perl) {
    if ($opt_output_yaml) {
        $p->output_yaml;
    }
    if ($opt_output_json) {
        $p->output_json;
    }
    if ($opt_output_perl) {
        $p->output_perl;
    }
} else {
    $p->set_papersize($opt_papersize) if defined $opt_papersize;
    $p->set_width($opt_width)         if defined $opt_width;
    $p->set_height($opt_height)       if defined $opt_height;
    $p->unit_type($opt_unit_type)     if defined $opt_unit_type;
    $p->color_type($opt_color_type)   if defined $opt_color_type;
    $p->set_modifiers(@opt_modifiers);

    if (!scalar @ARGV) {
        die("No paper ruling argument specified.\n");
    }

    foreach my $arg (@ARGV) {
        $p->generate_paper($arg);
    }
}

package My::Printable {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;

    INIT {
        public papersize,  default => "letter";
        public width,      default => 612;
        public height,     default => 792;
        public unit_type,  default => "imperial";
        public color_type, default => "color";

        public doc;
        public root;

        public canvas;
        public ruling;
        public left_margin;
        public right_margin;
        public bottom_margin;
        public top_margin;
        public x_origin;
        public y_origin;

        public unit;
        public unit_x;
        public unit_y;

        public modifiers;
    }

    sub init {
        my ($self) = @_;
        $self->unit(My::Printable::Unit->new);
        $self->unit_x(My::Printable::Unit->new);
        $self->unit_y(My::Printable::Unit->new);
    }

    use XML::LibXML;
    use List::Util qw(min max);
    use Data::Dumper qw(Dumper);
    use YAML qw(Dump);
    use JSON::PP;

    # use My::Printable::Util qw(exclude);
    sub exclude(\@@);      # for embedded package subs with prototypes
    INIT {
        import My::Printable::Util qw(exclude);
    }

    our $RULINGS;
    BEGIN {
        $RULINGS = {
            dot_grid => {
                unit => {
                    DEFAULT => "1/4in",
                    "metric" => "6mm",
                    "6mm" => "6mm",
                    "1/5in" => "1/5in",
                    "5mm" => "5mm",
                },
                dot_grid => {
                    x_spacing => "1unit",
                    y_spacing => "1unit",
                    class => {
                        DEFAULT => "blue dot",
                        grayscale => "gray dot",
                    },
                    x_coordinates_nearest_margins => 1,
                    y_coordinates_nearest_margins => 1,
                },
                left_margin_line => {
                    x => {
                        DEFAULT => "1.25in",
                        metric => "41mm",
                    },
                    nearest => "dot-grid",
                    class => {
                        DEFAULT => "red margin line",
                        grayscale => "gray margin line",
                    },
                },
            },
            line_dot_grid => {
                unit => {
                    DEFAULT => "1/4in",
                    "metric" => "6mm",
                    "6mm" => "6mm",
                    "1/5in" => "1/5in",
                    "5mm" => "5mm",
                },
                dot_grid => {
                    x_spacing => "1unit",
                    y_spacing => "1unit",
                    class => {
                        DEFAULT => {
                            DEFAULT => "semi-thick blue dot",
                            grayscale => "semi-thick gray dot",
                        },
                        "thinner-dots" => {
                            DEFAULT => "blue dot",
                            grayscale => "gray dot",
                        },
                        "x-thinner-dots" => {
                            DEFAULT => "semi-thin blue dot",
                            grayscale => "semi-thin gray dot",
                        },
                    },
                    top => {
                        DEFAULT => "1.5in",
                        metric => "37mm",
                    },
                },
                horizontal_lines => {
                    y_spacing => "1unit",
                    top => {
                        DEFAULT => "1.5in",
                        metric  => "37mm",
                    },
                    class => {
                        DEFAULT => {
                            DEFAULT => "thin blue line",
                            grayscale => "thin gray line",
                        },
                        "thinner-lines" => {
                            DEFAULT => "x-thin blue line",
                            grayscale => "x-thin gray line",
                        },
                        "x-thinner-lines" => {
                            DEFAULT => "xx-thin blue line",
                            grayscale => "xx-thin gray line",
                        },
                    },
                },
                left_margin_line => {
                    x => {
                        DEFAULT => "1.25in",
                        metric => "41mm",
                    },
                    nearest => "dot-grid",
                    class => {
                        DEFAULT => "red margin line",
                        grayscale => "gray margin line",
                    },
                },
            },
            line_dot_graph => {
                unit => {
                    DEFAULT => "5/16in",
                    "metric" => "8mm",
                    "8mm" => "8mm",
                    "10mm" => "10mm",
                },
                dot_grid => {
                    x_spacing => "1unit",
                    y_spacing => "1/4unit",
                    class => {
                        DEFAULT => "thin blue dot",
                        grayscale => "thin gray dot",
                    },
                    exclude => {
                        horizontal_lines => 1,
                    },
                },
                horizontal_lines => {
                    y_spacing => "1unit",
                    nearest_margins => 1,
                    bottom => {
                        DEFAULT => "1in",
                        metric => "28mm",
                    },
                    top => {
                        DEFAULT => "1.5in",
                        metric => "37mm",
                    },
                    class => {
                        DEFAULT => "thin blue line",
                        grayscale => "thin gray line",
                    },
                },
                left_margin_line => {
                    x => {
                        DEFAULT => "1.25in",
                        metric => "41mm",
                    },
                    nearest => "dot-grid",
                    class => {
                        DEFAULT => "red margin line",
                        grayscale => "gray margin line",
                    },
                },
            },
            seyes => {
                unit => {
                    DEFAULT => "5/16in",
                    metric => "8mm",
                    "8mm" => "8mm",
                    "10mm" => "10mm",
                },
                horizontal_lines => {
                    y_spacing => "1unit",
                    bottom => {
                        DEFAULT => "1in",
                        metric => "28mm",
                        smaller => {
                            DEFAULT => "0.75in",
                            metric => "19mm",
                        }
                    },
                    top => {
                        DEFAULT => "1.5in",
                        metric => "37mm",
                        smaller => {
                            DEFAULT => "1in",
                            metric => "24mm",
                        }
                    },
                    class => {
                        DEFAULT => "blue line",
                        grayscale => "gray line",
                    },
                    minor => {
                        every => 4,
                        extra => {
                            bottom => 2,
                            top => 3,
                        },
                        class => {
                            DEFAULT => {
                                DEFAULT => "thin blue line",
                                grayscale => "thin gray line",
                            },
                            "thinner-grid" => {
                                DEFAULT => "x-thin blue line",
                                grayscale => "x-thin gray line",
                            },
                        },
                    },
                },
                additional_horizontal_lines => [
                    {
                        DEFAULT => {
                            position => "top",
                            y => {
                                DEFAULT => "0.5in",
                                metric => "13mm",
                                smaller => {
                                    DEFAULT => "0.5in",
                                    metric => "13mm",
                                },
                            },
                            nearest_grid => {
                                DEFAULT => "horizontal_lines",
                                smaller => "minor_horizontal_lines",
                            },
                            class => {
                                DEFAULT => {
                                    DEFAULT => "thin blue line",
                                    grayscale => "thin gray line",
                                },
                                "thinner-grid" => {
                                    DEFAULT => "x-thin blue line",
                                    grayscale => "x-thin gray line",
                                },
                            },
                        },
                    },
                    {
                        DEFAULT => {
                            position => "bottom",
                            y => {
                                DEFAULT => "0.5in",
                                metric => "12mm",
                                smaller => {
                                    DEFAULT => "0.3125in",
                                    metric => "9mm",
                                }
                            },
                            left => {
                                DEFAULT => undef,
                                "even-page" => {
                                    x => {
                                        DEFAULT => "1unit",
                                        smaller => "2unit",
                                    },
                                    nearest_grid => "vertical_lines",
                                },
                            },
                            right => {
                                DEFAULT => {
                                    x => "1unit",
                                    nearest_grid => "vertical_lines",
                                },
                                "even-page" => undef,
                            },
                            width => "3unit",
                            nearest_grid => {
                                DEFAULT => "horizontal_lines",
                                smaller => "minor_horizontal_lines",
                            },
                            class => {
                                DEFAULT => {
                                    DEFAULT => "blue line",
                                    grayscale => "gray line",
                                },
                            },
                        },
                    },
                ],
                vertical_lines => {
                    x_spacing => "1unit",
                    nearest_margins => 1,
                    class => {
                        DEFAULT => {
                            DEFAULT => "thin blue line",
                            grayscale => "thin gray line",
                        },
                        "thinner-grid" => {
                            DEFAULT => "x-thin blue line",
                            grayscale => "x-thin gray line",
                        },
                    },
                    left => {
                        DEFAULT => {
                            DEFAULT => "1.25in",
                            metric => "41mm",
                        },
                        smaller => {
                            DEFAULT => "0.75in",
                            metric => "16mm",
                        }
                    },
                },
                left_margin_line => {
                    x => {
                        DEFAULT => {
                            DEFAULT => "1.25in",
                            metric => "41mm",
                        },
                        smaller => {
                            DEFAULT => "0.75in",
                            metric => "16mm",
                        }
                    },
                    nearest => "vertical-lines",
                    class => {
                        DEFAULT => "red margin line",
                        grayscale => "gray margin line",
                    },
                },
            },
        };
    }

    sub output_yaml {
        my ($self) = @_;
        my $string = Dump($RULINGS);
        print $string;
    }

    sub output_json {
        my ($self) = @_;
        my $json = JSON::PP->new->ascii(1)->pretty(1)->allow_nonref(1)->space_before(0)->indent_length(2);
        my $string = $json->encode($RULINGS);
        print $string;
    }

    sub output_perl {
        my ($self) = @_;
        local $Data::Dumper::Indent = 1; # standard indentation
        local $Data::Dumper::Trailingcomma = 1;
        local $Data::Dumper::Terse = 1; # output just the structure
        print Dumper($RULINGS);
    }

    sub set_papersize {
        my ($self, $spec) = @_;
        my ($name, $width, $height, $type) = My::Printable::PaperSizes->parse($spec);
        $self->unit_type($type);
        $self->papersize($name);
        $self->width($width);
        $self->height($height);
        $self->unit_x->set_percentage_basis($width);
        $self->unit_y->set_percentage_basis($height);
    }

    sub set_width {
        my ($self, $value, $unit) = @_;
        my ($pt, $type) = $self->unit->pt($value, $unit);
        $self->unit_type($type);
        $self->width($pt);
        $self->papersize(undef);
        $self->unit_x->set_percentage_basis($pt);
    }

    sub set_height {
        my ($self, $value, $unit) = @_;
        my ($pt, $type) = $self->unit->pt($value, $unit);
        $self->unit_type($type);
        $self->height($pt);
        $self->papersize(undef);
        $self->unit_y->set_percentage_basis($pt);
    }

    sub set_modifiers {
        my ($self, @modifiers) = @_;
        @modifiers = grep { defined $_ } @modifiers;
        $self->modifiers(\@modifiers);
    }

    sub generate_paper {
        my ($self, $ruling_name, %args) = @_;

        $ruling_name =~ s{-}{_}g;

        my $ruling = $RULINGS->{$ruling_name};
        if (!$ruling) {
            die("No such ruling: $ruling_name\n");
        }
        $self->ruling($ruling);

        $self->unit->delete_unit("unit");
        $self->unit_x->delete_unit("unit");
        $self->unit_y->delete_unit("unit");
        my $ruling_unit = $self->ruling_get("unit");
        if (defined $ruling_unit) {
            my $unit_pt = $self->unit->pt($ruling_unit);
            $self->unit->add_unit("unit", $unit_pt);
            $self->unit_x->add_unit("unit", $unit_pt);
            $self->unit_y->add_unit("unit", $unit_pt);
        }

        my $width  = $self->width;
        my $height = $self->height;

        my $ruling_left_margin   = $self->ruling_get("left_margin")   // 0;
        my $ruling_right_margin  = $self->ruling_get("right_margin")  // 0;
        my $ruling_bottom_margin = $self->ruling_get("bottom_margin") // 0;
        my $ruling_top_margin    = $self->ruling_get("top_margin")    // 0;
        my $ruling_x_origin      = $self->ruling_get("x_origin") // "50%";
        my $ruling_y_origin      = $self->ruling_get("y_origin") // "50%";

        my $left_margin  = $self->unit_x->pt($ruling_left_margin);
        my $right_margin = $self->width - $self->unit_x->pt($ruling_right_margin);

        my $bottom_margin = $self->unit_y->pt($ruling_bottom_margin);
        my $top_margin    = $self->height - $self->unit_y->pt($ruling_top_margin);

        my $x_origin = $self->unit_x->pt($ruling_x_origin);
        my $y_origin = $self->unit_y->pt($ruling_y_origin);

        $self->left_margin($left_margin);
        $self->right_margin($right_margin);
        $self->bottom_margin($bottom_margin);
        $self->top_margin($top_margin);
        $self->x_origin($x_origin);
        $self->y_origin($y_origin);

        my $doc = $self->create_document;
        my $root = $self->root;

        my $style = $self->create_style_element;
        $root->appendChild($style);

        my $canvas = $self->canvas({});
        $canvas->{dot_grid}                    = {};
        $canvas->{horizontal_lines}            = {};
        $canvas->{additional_horizontal_lines} = [];
        $canvas->{vertical_lines}              = {};
        $canvas->{margin_lines}                = {};

        # Compute points
        $self->compute_dot_grid;
        $self->compute_horizontal_lines;
        $self->compute_vertical_lines;
        $self->compute_margin_lines;
        $self->compute_additional_horizontal_lines;
        $self->chop_dot_grid;
        $self->chop_horizontal_lines;
        $self->compute_minor_horizontal_lines;
        $self->chop_vertical_lines;
        $self->relocate_margin_lines;
        $self->filter_grid_points;

        # Draw everything.
        $self->draw_dot_grid;
        $self->draw_minor_horizontal_lines;
        $self->draw_vertical_lines;
        $self->draw_horizontal_lines;
        $self->draw_additional_horizontal_lines;
        $self->draw_margin_lines;

        print $doc->toString(1);
    }

    sub compute_dot_grid {
        my ($self) = @_;
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        if ($self->ruling_get("dot_grid")) {
            my $dg_x_spacing = $self->ruling_get("dot_grid", "x_spacing") // "1unit";
            my $dg_y_spacing = $self->ruling_get("dot_grid", "y_spacing") // "1unit";
            my $dg_x_coordinates_nearest_margins = $self->ruling_get("dot_grid", "x_coordinates_nearest_margins");
            my $dg_y_coordinates_nearest_margins = $self->ruling_get("dot_grid", "y_coordinates_nearest_margins");
            my $x_spacing = $canvas_dot_grid->{x_spacing} = $self->unit_x->pt($dg_x_spacing);
            my $y_spacing = $canvas_dot_grid->{y_spacing} = $self->unit_y->pt($dg_y_spacing);
            $canvas_dot_grid->{x} = $self->get_points(
                spacing => $x_spacing,
                min => $self->left_margin,
                max => $self->right_margin,
                origin => $self->x_origin,
                nearest_margins => $dg_x_coordinates_nearest_margins,
            );
            $canvas_dot_grid->{y} = $self->get_points(
                spacing => $y_spacing,
                min => $self->bottom_margin,
                max => $self->top_margin,
                origin => $self->y_origin,
                nearest_margins => $dg_y_coordinates_nearest_margins,
            );
        }
    }

    sub compute_horizontal_lines {
        my ($self) = @_;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        if ($self->ruling_get("horizontal_lines")) {
            my $hl_y_spacing = $self->ruling_get("horizontal_lines", "y_spacing") // "1unit";
            my $y_spacing = $canvas_horizontal_lines->{y_spacing} = $self->unit_y->pt($hl_y_spacing);
            my $our_y_origin = $self->y_origin;
            if ($self->ruling_get("dot_grid")) {
                $our_y_origin = $canvas_dot_grid->{y}->[0];
            }
            $canvas_horizontal_lines->{y} = $self->get_points(
                spacing => $y_spacing,
                min => $self->bottom_margin,
                max => $self->top_margin,
                origin => $our_y_origin,
                nearest_margins => $self->ruling_get("horizontal_lines", "nearest_margins"),
            );
            $canvas_horizontal_lines->{unchopped_y} = $self->get_points(
                spacing => $y_spacing,
                min => $self->bottom_margin,
                max => $self->top_margin,
                origin => $our_y_origin,
                nearest_margins => $self->ruling_get("horizontal_lines", "nearest_margins"),
            );
        }
    }

    sub compute_additional_horizontal_lines {
        my ($self) = @_;
        my $canvas_additional_horizontal_lines = $self->canvas->{additional_horizontal_lines} //= [];
        my $ahls = $self->ruling_get("additional_horizontal_lines");
        return if !$ahls || ref $ahls ne "ARRAY";
        foreach my $ahl (@$ahls) {
            $ahl = $self->get($ahl);
            next if !$ahl;

            my $ahl_position     = $self->get($ahl, "position");
            my $ahl_x            = $self->get($ahl, "x");
            my $ahl_y            = $self->get($ahl, "y");
            my $ahl_nearest_grid = $self->get($ahl, "nearest_grid");
            my $ahl_left         = $self->get($ahl, "left");
            my $ahl_right        = $self->get($ahl, "right");
            my $ahl_left_x       = $self->get($ahl, "left", "x");
            my $ahl_right_x      = $self->get($ahl, "right", "x");
            my $ahl_left_ng      = $self->get($ahl, "left", "nearest_grid");
            my $ahl_right_ng     = $self->get($ahl, "right", "nearest_grid");
            my $ahl_width        = $self->get($ahl, "width");
            my $ahl_class        = $self->get($ahl, "class") // $self->ruling_get("horizontal_lines", "class");

            my $y;
            if ($ahl_position eq "bottom") {
                $y = $self->unit_y->pt($ahl_y);
            } elsif ($ahl_position eq "top") {
                $y = $self->height - $self->unit_y->pt($ahl_y);
            }
            if ($ahl_nearest_grid eq "horizontal_lines") {
                $y = $self->point_nearest($y, @{$self->canvas->{horizontal_lines}->{unchopped_y}});
            }

            my $x1;
            my $x2;
            if (defined $ahl_left) {
                $x1 = $self->unit_x->pt($ahl_left_x);
                if ($ahl_left_ng eq "vertical_lines") {
                    $x1 = $self->point_nearest($x1, @{$self->canvas->{vertical_lines}->{unchopped_x}});
                }
            }
            if (defined $ahl_right) {
                $x2 = $self->width - $self->unit_x->pt($ahl_right_x);
                if ($ahl_right_ng eq "vertical_lines") {
                    $x2 = $self->point_nearest($x2, @{$self->canvas->{vertical_lines}->{unchopped_x}});
                }
            }

            if (defined $ahl_left && !defined $ahl_right && defined $ahl_width) {
                $x2 = $x1 + $self->unit_x->pt($ahl_width);
            }
            if (defined $ahl_right && !defined $ahl_left && defined $ahl_width) {
                $x1 = $x2 - $self->unit_x->pt($ahl_width);
            }

            push(@{$canvas_additional_horizontal_lines}, {
                x1 => $x1,
                x2 => $x2,
                y => $y,
                class => $ahl_class,
            });
        }
    }

    sub compute_vertical_lines {
        my ($self) = @_;
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        if ($self->ruling_get("vertical_lines")) {
            my $vl_x_spacing = $self->ruling_get("vertical_lines", "x_spacing") // "1unit";
            my $x_spacing = $canvas_vertical_lines->{x_spacing} = $self->unit_x->pt($vl_x_spacing);
            my $our_x_origin = $self->x_origin;
            if ($self->ruling_get("dot_grid")) {
                $our_x_origin = $canvas_dot_grid->{x}->[0];
            }
            $canvas_vertical_lines->{x} = $self->get_points(
                spacing => $x_spacing,
                min => $self->left_margin,
                max => $self->right_margin,
                origin => $our_x_origin,
                nearest_margins => $self->ruling_get("vertical_lines", "nearest_margins"),
            );
            $canvas_vertical_lines->{unchopped_x} = $self->get_points(
                spacing => $x_spacing,
                min => $self->left_margin,
                max => $self->right_margin,
                origin => $our_x_origin,
                nearest_margins => $self->ruling_get("vertical_lines", "nearest_margins"),
            );
        }
    }

    sub compute_margin_lines {
        my ($self) = @_;
        my $canvas_margin_lines = $self->canvas->{margin_lines};
        if ($self->ruling_get("left_margin_line")) {
            $canvas_margin_lines->{left}->{x} = $self->unit_x->pt($self->ruling_get("left_margin_line", "x"));
        }
    }

    sub chop_dot_grid {
        my ($self) = @_;
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        my $height = $self->height;
        my $width = $self->width;
        if ($self->ruling_get("dot_grid")) {
            my $x = $canvas_dot_grid->{x};
            my $y = $canvas_dot_grid->{y};

            my $bottom = $self->ruling_get("dot_grid", "bottom");
            my $top    = $self->ruling_get("dot_grid", "top");
            my $left   = $self->ruling_get("dot_grid", "left");
            my $right  = $self->ruling_get("dot_grid", "right");

            if (defined $bottom) {
                my $bottom_y = $self->unit_y->pt($bottom);
                $bottom_y = $self->point_nearest($bottom_y, @$y);
                @$y = grep { $_ >= $bottom_y } @$y;
            }
            if (defined $top) {
                my $top_y = $height - $self->unit_y->pt($top);
                $top_y = $self->point_nearest($top_y, @$y);
                @$y = grep { $_ <= $top_y } @$y;
            }
            if (defined $left) {
                my $left_x = $self->unit_x->pt($left);
                $left_x = $self->point_nearest($left_x, @$x);
                @$x = grep { $_ >= $left_x } @$x;
            }
            if (defined $right) {
                my $right_x = $width - $self->unit_x->pt($right);
                $right_x = $self->point_nearest($right_x, @$x);
                @$x = grep { $_ <= $right_x } @$x;
            }
        }
    }

    sub chop_horizontal_lines {
        my ($self) = @_;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        my $height = $self->height;
        if ($self->ruling_get("horizontal_lines")) {
            my $y = $canvas_horizontal_lines->{y};

            my $bottom = $self->ruling_get("horizontal_lines", "bottom");
            if (defined $bottom) {
                my $bottom_y = $self->unit_y->pt($bottom);
                $bottom_y = $self->point_nearest($bottom_y, @$y);
                @$y = grep { $_ >= $bottom_y } @$y;
            }

            my $top = $self->ruling_get("horizontal_lines", "top");
            if (defined $top) {
                my $top_y = $height - $self->unit_y->pt($top);
                $top_y = $self->point_nearest($top_y, @$y);
                @$y = grep { $_ <= $top_y } @$y;
            }
        }
    }

    sub chop_vertical_lines {
        my ($self) = @_;
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        my $width = $self->width;
        if ($self->ruling_get("vertical_lines")) {
            my $x = $canvas_vertical_lines->{x};

            my $left = $self->ruling_get("vertical_lines", "left");
            if (defined $left) {
                my $left_x = $self->unit_x->pt($left);
                $left_x = $self->point_nearest($left_x, @$x);
                @$x = grep { $_ >= $left_x } @$x;
            }

            my $right = $self->ruling_get("vertical_lines", "right");
            if (defined $right) {
                my $right_x = $width - $self->unit_x->pt($right);
                $right_x = $self->point_nearest($right_x, @$x);
                @$x = grep { $_ <= $right_x } @$x;
            }
        }
    }

    sub compute_minor_horizontal_lines {
        my ($self) = @_;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        if ($self->ruling_get("horizontal_lines", "minor")) {
            my $y = $canvas_horizontal_lines->{y};
            my $every        = $self->ruling_get("horizontal_lines", "minor", "every");
            my $extra_bottom = $self->ruling_get("horizontal_lines", "minor", "extra", "bottom") // 0;
            my $extra_top    = $self->ruling_get("horizontal_lines", "minor", "extra", "top")    // 0;
            my $y_bottom = min @$y;
            my $y_top    = max @$y;
            my $y_spacing = $canvas_horizontal_lines->{y_spacing} / $every;
            my $new_y_bottom = $y_bottom - ($extra_bottom + 0.5) * $y_spacing;
            my $new_y_top    = $y_top    + ($extra_top    + 0.5) * $y_spacing;
            my $minor_y = $canvas_horizontal_lines->{minor}->{y} = $self->get_points(
                spacing => $y_spacing,
                min => $new_y_bottom,
                max => $new_y_top,
                origin => $y_bottom
            );
            @$minor_y = exclude(@$minor_y, @{$canvas_horizontal_lines->{y}});
        }
    }

    sub relocate_margin_lines {
        my ($self) = @_;
        my $canvas_margin_lines = $self->canvas->{margin_lines};
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        if ($self->ruling_get("left_margin_line")) {
            my $nearest = $self->ruling_get("left_margin_line", "nearest");
            if (defined $nearest) {
                if ($nearest eq "dot-grid" && $self->ruling_get("dot_grid")) {
                    $canvas_margin_lines->{left}->{x} = $self->point_nearest($canvas_margin_lines->{left}->{x},
                                                                             @{$canvas_dot_grid->{x}});
                }
                if ($nearest eq "vertical-lines" && $self->ruling_get("vertical_lines")) {
                    $canvas_margin_lines->{left}->{x} = $self->point_nearest($canvas_margin_lines->{left}->{x},
                                                                             @{$canvas_vertical_lines->{x}});
                }
            }
        }
    }

    sub filter_grid_points {
        my ($self) = @_;
        my $canvas_margin_lines = $self->canvas->{margin_lines};
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        if ($self->ruling_get("dot_grid")) {
            my $x = $canvas_dot_grid->{x};
            my $y = $canvas_dot_grid->{y};
            my $exclude     = $self->ruling_get("dot_grid", "exclude");
            my $exclude_hl  = $self->ruling_get("dot_grid", "exclude", "horizontal_lines");
            my $exclude_mhl = $self->ruling_get("dot_grid", "exclude", "minor_horizontal_lines");
            my $exclude_vl  = $self->ruling_get("dot_grid", "exclude", "vertical_lines");
            my $exclude_lml = $self->ruling_get("dot_grid", "exclude", "left_margin_line");
            my $has_hl      = $self->ruling_get("horizontal_lines");
            my $has_mhl     = $self->ruling_get("horizontal_lines", "minor");
            my $has_vl      = $self->ruling_get("vertical_lines");
            my $has_lml     = $self->ruling_get("left_margin_line");
            if ($has_hl && $exclude_hl) {
                @$y = exclude(@$y, @{$canvas_horizontal_lines->{y}});
            }
            if ($has_mhl && $exclude_mhl) {
                @$y = exclude(@$y, @{$canvas_horizontal_lines->{minor}->{y}});
            }
            if ($has_vl && $exclude_vl) {
                @$x = exclude(@$x, @{$canvas_vertical_lines->{x}});
            }
            if ($has_lml && $exclude_lml) {
                @$x = exclude(@$x, ($canvas_margin_lines->{left}->{x}));
            }
        }
    }

    sub draw_dot_grid {
        my ($self) = @_;
        my $canvas_dot_grid = $self->canvas->{dot_grid};
        if ($self->ruling_get("dot_grid")) {
            my $layer = $self->layer("dot-grid");
            foreach my $x (@{$canvas_dot_grid->{x}}) {
                foreach my $y (@{$canvas_dot_grid->{y}}) {
                    my $line = $self->create_line(
                        x => $x, y => $y,
                        class => $self->ruling_get("dot_grid", "class") // "thin blue dot",
                    );
                    $layer->appendChild($line);
                }
            }
        }
    }

    sub draw_horizontal_lines {
        my ($self) = @_;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        if ($self->ruling_get("horizontal_lines")) {
            my $layer = $self->layer("horizontal-lines");
            foreach my $y (@{$canvas_horizontal_lines->{y}}) {
                my $x1 = $self->left_margin;
                my $x2 = $self->right_margin;
                my $line = $self->create_line(
                    x1 => $x1, x2 => $x2, y => $y,
                    class => $self->ruling_get("horizontal_lines", "class") // "thin blue line",
                );
                $layer->appendChild($line);
            }
        }
    }

    sub draw_additional_horizontal_lines {
        my ($self) = @_;
        my $canvas_additional_horizontal_lines = $self->canvas->{additional_horizontal_lines};
        my $layer = $self->layer("additional-horizontal-lines");
        if ($self->ruling_get("horizontal_lines")) {
            foreach my $line (@{$canvas_additional_horizontal_lines}) {
                my $y  = $line->{y};
                my $x1 = $line->{x1} // $self->left_margin;
                my $x2 = $line->{x2} // $self->right_margin;
                my $line = $self->create_line(
                    x1 => $x1,
                    x2 => $x2,
                    y => $y,
                    class => $line->{class} // "thin blue line"
                );
                $layer->appendChild($line);
            }
        }
    }

    sub draw_minor_horizontal_lines {
        my ($self) = @_;
        my $canvas_horizontal_lines = $self->canvas->{horizontal_lines};
        if ($self->ruling_get("horizontal_lines", "minor")) {
            my $layer = $self->layer("minor-horizontal-lines");
            my $minor = $canvas_horizontal_lines->{minor};
            if (defined $minor) {
                foreach my $y (@{$minor->{y}}) {
                    my $x1 = $self->left_margin;
                    my $x2 = $self->right_margin;
                    my $line = $self->create_line(
                        x1 => $x1, x2 => $x2, y => $y,
                        class => $self->ruling_get("horizontal_lines", "minor", "class") // "x-thin blue line",
                    );
                    $layer->appendChild($line);
                }
            }
        }
    }

    sub draw_vertical_lines {
        my ($self) = @_;
        my $canvas_vertical_lines = $self->canvas->{vertical_lines};
        if ($self->ruling_get("vertical_lines")) {
            my $layer = $self->layer("vertical-lines");
            foreach my $x (@{$canvas_vertical_lines->{x}}) {
                my $y1 = $self->bottom_margin;
                my $y2 = $self->top_margin;
                my $line = $self->create_line(
                    y1 => $y1, y2 => $y2, x => $x,
                    class => $self->ruling_get("vertical_lines", "class") // "thin blue line",
                );
                $layer->appendChild($line);
            }
        }
    }

    sub draw_margin_lines {
        my ($self) = @_;
        my $canvas_margin_lines = $self->canvas->{margin_lines};
        if ($self->get("left_margin_line")) {
            my $layer = $self->layer("margin-lines");
            my $margin_line = $self->create_line(
                x => $canvas_margin_lines->{left}->{x},
                y1 => $self->bottom_margin,
                y2 => $self->top_margin,
                class => $self->ruling_get("left_margin_line", "class") // "red margin line",
            );
            $layer->appendChild($margin_line);
        }
    }

    sub get_points {
        my ($self, %args) = @_;
        my $spacing = $args{spacing};
        my $origin  = $args{origin};
        my $min     = $args{min};
        my $max     = $args{max};
        my $nearest_margins = delete $args{nearest_margins};
        my $nearest_margin_line = delete $args{nearest_margin_line};

        if ($nearest_margins) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $min1 = $points1[0];

            my $min2 = $points2[0];
            if ($min1 < $min2) {
                return @points1 if wantarray;
                return \@points1;
            }
            return @points2 if wantarray;
            return \@points2;
        }

        if ($nearest_margin_line) {
            my @points1 = $self->get_points(%args);
            my %args2 = %args;
            $args2{origin} += $spacing / 2;
            if ($args2{origin} > $max) {
                $args2{origin} -= $spacing;
            }
            my @points2 = $self->get_points(%args2);
            my $point1 = $self->point_nearest($nearest_margin_line, @points1);
            my $point2 = $self->point_nearest($nearest_margin_line, @points2);
            my $dist1 = abs($point1 - $nearest_margin_line);
            my $dist2 = abs($point2 - $nearest_margin_line);
            if ($dist1 < $dist2) {
                return @points1 if wantarray;
                return \@points1;
            }
            return @points2 if wantarray;
            return \@points2;
        }

        my @points = ($origin);
        $spacing = $self->unit->pt($spacing);
        my $x;
        for ($x = $origin + $spacing; $x <= $max; $x += $spacing) {
            push(@points, $x);
        }
        for ($x = $origin - $spacing; $x >= $min; $x -= $spacing) {
            unshift(@points, $x);
        }
        return @points if wantarray;
        return \@points;
    }


    sub point_nearest {
        my ($self, $x, @points) = @_;
        my @dist = map { abs($x - $_) } @points;
        my $mindist = min(@dist);
        for (my $i = 0; $i < scalar @points; $i += 1) {
            if ($mindist == $dist[$i]) {
                return $points[$i];
            }
        }
        return undef;           # should NEVER happen.
    }

    sub create_line {
        my ($self, %args) = @_;
        my $doc = $self->doc;
        my $line = $doc->createElement("line");
        my $x1 = $args{x1} // $args{x};
        my $x2 = $args{x2} // $args{x};
        my $y1 = $args{y1} // $args{y};
        my $y2 = $args{y2} // $args{y};
        $y1 = $self->height - $y1;
        $y2 = $self->height - $y2;
        $line->setAttribute("x1", $x1);
        $line->setAttribute("x2", $x2);
        $line->setAttribute("y1", $y1);
        $line->setAttribute("y2", $y2);
        $line->setAttribute("class", $args{class}) if defined $args{class};
        return $line;
    }

    sub create_document {
        my ($self) = @_;
        my $width = $self->width;
        my $height = $self->height;
        my $viewBox = sprintf("%f %f %f %f", 0, 0, $width, $height);
        my $doc = $self->doc(XML::LibXML::Document->new("1.0", "UTF-8"));
        my $root = $self->root($doc->createElement("svg"));
        $root->setAttribute("width", $width . "pt");
        $root->setAttribute("height", $height . "pt");
        $root->setAttribute("viewBox", $viewBox);
        $root->setAttribute("xmlns", "http://www.w3.org/2000/svg");
        $doc->setDocumentElement($root);
        return $doc;
    }

    sub create_style_element {
        my ($self, $css) = @_;

        my $xx_thin_line_stroke_width    = $self->unit->pt("2/600in");
        my $x_thin_line_stroke_width     = $self->unit->pt("3/600in");
        my $thin_line_stroke_width       = $self->unit->pt("4/600in");
        my $semi_thin_line_stroke_width  = $self->unit->pt("4.9/600in");
        my $line_stroke_width            = $self->unit->pt("6/600in");
        my $semi_thick_line_stroke_width = $self->unit->pt("7.35/600in");
        my $thick_line_stroke_width      = $self->unit->pt("9/600in");

        my $thin_dot_stroke_width        = $self->unit->pt("4/300in");
        my $semi_thin_dot_stroke_width   = $self->unit->pt("4.9/300in");
        my $dot_stroke_width             = $self->unit->pt("6/300in");
        my $semi_thick_dot_stroke_width  = $self->unit->pt("7.35/300in");
        my $thick_dot_stroke_width       = $self->unit->pt("9/300in");

        $css //= <<"EOF";
            .line, .dot { stroke-linecap: round; }

            .line            { stroke-width: ${line_stroke_width}pt; }
            .line.xx-thin    { stroke-width: ${xx_thin_line_stroke_width}pt; }
            .line.x-thin     { stroke-width: ${x_thin_line_stroke_width}pt; }
            .line.thin       { stroke-width: ${thin_line_stroke_width}pt; }
            .line.thick      { stroke-width: ${thick_line_stroke_width}pt; }
            .line.semi-thin  { stroke-width: ${semi_thin_line_stroke_width}pt; }
            .line.semi-thick { stroke-width: ${semi_thick_line_stroke_width}pt; }

            .dot             { stroke-width: ${dot_stroke_width}pt; }
            .dot.thin        { stroke-width: ${thin_dot_stroke_width}pt; }
            .dot.thick       { stroke-width: ${thick_dot_stroke_width}pt; }
            .dot.semi-thin   { stroke-width: ${semi_thin_dot_stroke_width}pt; }
            .dot.semi-thick  { stroke-width: ${semi_thick_dot_stroke_width}pt; }

            .blue  { stroke: #b3b3ff; }
            .red   { stroke: #ff9999; }
            .green { stroke: #b3ffb3; }
            .gray  { stroke: #b3b3b3; }

            .light.blue  { stroke: #d9d9ff; }
            .light.red   { stroke: #ffcccc; }
            .light.green { stroke: #d9ffd9; }
            .light.gray  { stroke: #d9d9d9; }

            .dark.blue  { stroke: #6767ff; }
            .dark.red   { stroke: #ff3333; }
            .dark.green { stroke: #67ff67; }
            .dark.gray  { stroke: #676767; }

            .alternate-blue  { stroke: #6767ff; opacity: 0.5; }
            .alternate-red   { stroke: #ff3333; opacity: 0.5; }
            .alternate-green { stroke: #67ff67; opacity: 0.5; }
            .alternate-gray  { stroke: #676767; opacity: 0.5; }
EOF
        my $doc = $self->doc;
        my $style = $doc->createElement("style");
        $style->appendText($css);
        return $style;
    }

    sub create_g_element {
        my ($self, $id) = @_;
        my $doc = $self->doc;
        my $g = $doc->createElement("g");
        $g->setAttribute("id", $id);
        return $g;
    }

    sub layer {
        my ($self, $id) = @_;
        my $doc = $self->doc;
        my $root = $self->root;
        my ($layer) = $doc->findnodes("//*[\@id='" . $id . "']");
        if ($layer) {
            return $layer;
        }
        $layer = $self->create_g_element($id);
        $root->appendChild($layer);
        return $layer;
    }

    sub value {
        my ($self, $value) = @_;
        return undef if !defined $value;
        return $value if ref $value ne "HASH";
        return $value if !exists $value->{DEFAULT};
        my $valuehash = $value;
        $value = $valuehash->{DEFAULT};
        foreach my $modifier (@{$self->modifiers}, $self->unit_type, $self->color_type) {
            if (exists $valuehash->{$modifier}) {
                $value = $valuehash->{$modifier};
            }
        }
        return $self->value($value);
    }

    sub ruling_get {
        my ($self, @props) = @_;
        return $self->get($self->{ruling}, @props);
    }

    sub get {
        my ($self, $o, $prop, @other_props) = @_;
        if (!defined $o) {
            return undef;
        }
        if (ref $o ne "HASH") {
            if (defined $prop) {
                return undef;
            }
            return $o;
        }
        if (exists $o->{DEFAULT}) {
            my $next = $o->{DEFAULT};
            foreach my $modifier (@{$self->modifiers},
                                  $self->unit_type,
                                  $self->color_type) {
                if (exists $o->{$modifier}) {
                    $next = $o->{$modifier};
                }
            }
            return $self->get($next, $prop, @other_props);
        }
        if (!defined $prop) {
            return $o;
        }
        if (!exists $o->{$prop}) {
            return undef;
        }
        return $self->get($o->{$prop}, @other_props);
    }
};

package My::Printable::Unit {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;

    our $UNITS;
    BEGIN {
        $UNITS = {
            "pt" => {
                to_pt => 1,
                type => "imperial",
            },
            "pc" => {
                to_pt => 12,    # 1 pc = 12 pt
                type => "imperial",
            },
            "in" => {
                to_pt => 72,    # 1 in = 72 pt
                type => "imperial",
            },
            "cm" => {
                to_pt => (72 / 2.54), # 1 cm ~= 28.3465 pt
                type => "metric",
            },
            "mm" => {
                to_pt => (72 / 25.4), # 1 cm ~= 2.83465 pt
                type => "metric",
            },
            "px" => {
                to_pt => (72 / 96), # 1 px = 0.75 pt
                type => "imperial"
            },
            "pd" => {           # pixel dots
                to_pt => (72 / 300), # 1 pd = 1 dot on a 300dpi laser printer = 1/300 in = 72/300 pt
                type => "imperial"
            }
        };
    }

    sub init {
        my ($self) = @_;
        $self->{units} = { %$UNITS }; # shallow copy
    }

    sub set_percentage_basis {
        my ($self, $value, $unit) = @_;
        delete $self->{units}->{'%'};
        $self->add_unit('%', $value / 100, $unit);
    }

    sub add_unit {
        my ($self, $unit, $value, $value_unit) = @_;
        die("Unit already defined: $unit\n") if exists $self->{units}->{$unit};
        my ($pt, $type) = $self->pt($value, $value_unit);
        $self->{units}->{$unit} = {
            to_pt => $pt,
            type => $type
        };
    }

    sub delete_unit {
        my ($self, $unit) = @_;
        delete $self->{units}->{$unit};
    }

    sub rx_units {
        my ($self) = @_;
        $self = object($self);

        my @units = sort keys %{$self->{units}};
        my $units = join('|', map { quotemeta($_) } @units);
        return qr{$units}xi;
    }

    sub rx_number {
        my ($self) = @_;
        $self = object($self);

        return qr{\d+(?:\.\d*)?|\.\d+}ix;
    }

    sub pt {
        my ($self, $value, $unit) = @_;
        $self = object($self);

        return undef if !defined $value;

        my ($numerator, $denominator);

        my $rx_units  = $self->rx_units;
        my $rx_number = $self->rx_number;
        my $spec;

        if (defined $unit) {
            $spec = "$value $unit";
            if ($value =~ m{\A
                            \s*
                            ($rx_number)
                            (?:
                                \s*
                                /
                                \s*
                                ($rx_number)
                            )?
                            \s*
                            \z}xi) {
                ($numerator, $denominator) = ($1, $2);
            } else {
                die("Invalid size specification: $value $unit\n");
            }
        } else {
            $spec = "$value";
            if ($value =~ m{\A
                            \s*
                            ($rx_number)
                            (?:
                                \s*
                                /
                                \s*
                                ($rx_number)
                            )?
                            \s*
                            ($rx_units)?
                            \s*
                            \z}xi) {
                ($numerator, $denominator, $unit) = ($1, $2, $3);
            } else {
                die("Invalid size specification: $spec\n");
            }
        }

        my $number;
        if (defined $denominator) {
            $number = $numerator / $denominator;
        } else {
            $number = $numerator;
        }

        if (!defined $unit || $unit eq "") {
            return ($number, "imperial") if wantarray;
            return $number;
        }

        my $unit_info = $self->{units}->{$unit};
        if (!defined $unit_info) {
            die("Invalid size specification: $spec\n");
        }

        my $result_pt   = $number * $unit_info->{to_pt};
        my $result_type = $unit_info->{type};

        return ($result_pt, $result_type) if wantarray;
        return $result_pt;
    }

    our $SINGLETON;

    sub object {
        my ($self) = @_;
        if (!ref $self) {
            $self = ($SINGLETON //= __PACKAGE__->new);
        }
        return $self;
    }
};

package My::Printable::PaperSizes {

    use lib "$ENV{HOME}/git/dse.d/perl-class-thingy/lib";
    use Class::Thingy;

    use POSIX qw(round);

    our $SIZES;
    INIT {
        $SIZES = {
            letter => {
                width  => scalar(My::Printable::Unit->pt(8.5, "in")),
                height => scalar(My::Printable::Unit->pt(11, "in")),
                type   => "imperial",
            },
            a4 => {
                width  => scalar(My::Printable::Unit->pt(250 / sqrt(sqrt(2)), "mm")),
                height => scalar(My::Printable::Unit->pt(250 * sqrt(sqrt(2)), "mm")),
                type   => "metric",
            },
            halfletter => {
                width  => scalar(My::Printable::Unit->pt(5.5, "in")),
                height => scalar(My::Printable::Unit->pt(8.5, "in")),
                type   => "imperial",
            },
        };
    }

    sub parse {
        my ($self, $spec) = @_;
        $spec = lc $spec;

        my $result =
            $self->parse_builtin_papersize($spec) //
            $self->parse_custom_papersize($spec) //
            $self->parse_paperconf_papersize($spec);
        if (wantarray) {
            return ($result->{name},
                    $result->{width},
                    $result->{height},
                    $result->{type});
        }
        return $result;
    }

    sub parse_builtin_papersize {
        my ($self, $spec) = @_;
        $spec = lc $spec;

        my $info = $SIZES->{spec};
        return if !$info;

        $info = { %$info };     # shallow copy
        $info->{name} //= $spec;
        return $info;
    }

    sub parse_paperconf_papersize {
        my ($self, $spec) = @_;
        $spec = lc $spec;

        my $ph;
        my @cmd;
        if (defined $spec) {
            @cmd = ("paperconf", "-p", $spec, "-n", "-s");
        } else {
            @cmd = ("paperconf", "-n", "-s");
        }
        if (!open($ph, "-|", @cmd)) {
            warn("exec paperconf: $!");
            return;
        }
        local $/ = undef;
        my $result = <$ph>;
        if (!close($ph)) {
            warn("paperconf failed: $!");
            return;
        }
        $result =~ s{\A\s+}{};
        $result =~ s{\s+\z}{};

        my ($name, $width, $height) = split(' ', $result);
        my $type;
        if ($width == round($width) && $height == round($height)) {
            $type = "imperial";
        } else {
            $type = "metric";
        }

        return {
            name => $name,
            width => $width,
            height => $height,
            type   => $type
        };
    }

    sub parse_custom_papersize {
        my ($self, $spec) = @_;
        $spec = lc $spec;

        my $rx_number = My::Printable::Unit->rx_number;
        my $rx_units  = My::Printable::Unit->rx_units;

        if ($spec =~ m{\A
                       \s*
                       ($rx_number)
                       (?:
                           \s*
                           /
                           \s*
                           ($rx_number)
                       )?
                       \s*
                       ($rx_units)?
                       \s*
                       (?:\*|x)
                       \s*
                       ($rx_number)
                       (?:
                           \s*
                           /
                           \s*
                           ($rx_number)
                       )?
                       \s*
                       ($rx_units)?
                       \s*
                       \z}xi) {
            my ($width, $width_denominator, $x_unit,
                $height, $height_denominator, $y_unit) = ($1, $2, $3, $4, $5, $6);

            $width  /= $width_denominator  if defined $width_denominator;
            $height /= $height_denominator if defined $height_denominator;

            if (!defined $y_unit || $y_unit eq "") {
                $y_unit = "pt";
            }
            if (!defined $x_unit || $x_unit eq "") {
                $x_unit = $y_unit;
            }

            my $x_type;
            my $y_type;
            ($width,  $x_type) = My::Printable::Unit->pt($width,  $x_unit);
            ($height, $y_type) = My::Printable::Unit->pt($height, $y_unit);

            my $type = $x_type // $y_type;
            if (wantarray) {
                return (undef, $width, $height, $type);
            }
            return {
                width  => $width,
                height => $height,
                type   => $type
            };
        }
        return;
    }

    our $SINGLETON;

    sub object {
        my ($self) = @_;
        if (!ref $self) {
            $self = ($SINGLETON //= __PACKAGE__->new);
        }
        return $self;
    }
};

package My::Printable::Util {
    use base "Exporter";

    our @EXPORT_OK;
    BEGIN {
        push(@EXPORT_OK, 'exclude');
    }

    use Data::Dumper;

    sub exclude(\@@);
    sub exclude(\@@) {
        my ($a, @b) = @_;
        my %b = map { ($_, 1) } @b;
        return grep { !$b{$_} } @$a;
    }
};
