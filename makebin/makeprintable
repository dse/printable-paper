#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

use lib "$ENV{HOME}/git/dse.d/printable-paper/lib";
use My::Printable::Document;
use My::Printable::Ruling;

use String::ShellQuote qw(shell_quote);
use Cwd qw(realpath);
use File::Path qw(mkpath);
use File::Basename qw(dirname basename);
use File::Find qw(find);
use Text::Trim qw(trim);
use Getopt::Long qw();
use Data::Dumper qw(Dumper);
use Storable qw(dclone);

our $opt_verbose = 0;
our $opt_dry_run = 0;

Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'v|verbose+' => \$opt_verbose,
    'n|dry-run'  => \$opt_dry_run,
    'quiet'      => sub {
        if ($opt_verbose < 0) {
            $opt_verbose -= 1;
        } else {
            $opt_verbose = -1;
        }
    },
    'h|help' => sub { usage(); exit 0; },
) or die("Type '$0 --help' for help.\n");

sub usage { print <<END; }
usage: $0 [<option> ...] [<keyword> ...]
options:
  -h, --help
  -v, --verbose
  -n, --dry-run
END

my $progname = realpath($0);
my $progdir = dirname($progname);
chdir($progdir);
my $projdir = trim(`git rev-parse --show-toplevel 2>/dev/null`);
if ($? || !defined $projdir || $projdir !~ m{\S}) {
    die("not in a git project\n");
}
chdir($projdir);

my @sizes = (
    { size => 'letter' },
    { size => 'a4' },
    { size => 'halfletter', '2up' => 'letter' },
    { size => 'a5',         '2up' => 'a4'     },
);

my @collections = (
    {
        ruling => 'doane',
        sizes => [@sizes],
        variants => [
            [qw()],
            [qw(denser-grid)],
        ],
        color_types => ['color', 'black'],
    },
    {
        ruling => 'quadrille',
        sizes => [@sizes],
        variants => [
            [qw()],
            [qw(5-per-inch)],
        ],
        color_types => ['color', 'black'],
    },
    {
        ruling => 'line-dot-grid',
        sizes => [@sizes],
        variants => [
            [qw()],
            { name => 'thinner',   modifiers => [qw(thinner-dots thinner-lines)]     },
            { name => 'x-thinner', modifiers => [qw(x-thinner-dots x-thinner-lines)] },
        ],
        color_types => ['color', 'black'],
    },
    {
        ruling => 'seyes',
        sizes => [@sizes],
        variants => [
            { modifiers => []                            },
            { modifiers => [qw(thinner-grid)]            },
            { modifiers => [qw(three-line)]              },
            { modifiers => [qw(three-line thinner-grid)] },
        ],
        color_types => ['color', 'black'],
    },
    {
        ruling => 'dot-grid',
        sizes => [@sizes],
        color_types => ['color', 'black'],
    },
    {
        ruling => 'line-dot-graph',
        sizes => [@sizes],
        color_types => ['color', 'black'],
    },
);

use constant USE_OLD_FILENAMES => 1;

my @templates;

foreach my $collection (@collections) {
    my $ruling      = $collection->{ruling};
    my $sizes       = $collection->{sizes};
    my $variants    = $collection->{variants};
    my $color_types = $collection->{color_types} // ['color'];
    if (!$variants) {
        $variants = [
            { modifiers => [] },
        ];
    }
    foreach my $color_type (@$color_types) {
        foreach my $size (@$sizes) {
            my $size_name = (ref $size eq 'HASH') ? $size->{size}  : $size;
            my $size_2up  = (ref $size eq 'HASH') ? $size->{'2up'} : undef;
            foreach my $variant (@$variants) {
                my $variant_modifiers =
                    ((ref $variant eq 'ARRAY') ? $variant :
                     (ref $variant eq 'HASH') ? $variant->{modifiers} :
                     undef) // [];
                my $variant_name =
                    ((ref $variant eq 'HASH') ? $variant->{name} :
                     undef) // join('--', @$variant_modifiers);

                my $base = $ruling;
                $base .= '/' . $color_type;
                $base .= '/' . $ruling;

                if (USE_OLD_FILENAMES) {
                    if ($color_type ne 'color') {
                        $base .= '--' . $color_type;
                    }
                } else {
                    $base .= '--' . $color_type;
                }

                if (USE_OLD_FILENAMES) {
                    if (defined $variant_name && $variant_name ne '') {
                        $base .= '--' . $variant_name;
                    }
                }

                $base .= '--' . $size_name;

                if (!USE_OLD_FILENAMES) {
                    if (defined $variant_name && $variant_name ne '') {
                        $base .= '--' . $variant_name;
                    }
                }

                my $base_2up;
                if ($size_2up) {
                    $base_2up = $base;
                    $base_2up .= '-2up-' . $size_2up;
                }

                my $template = {
                    base       => $base,
                    ruling     => $ruling,
                    color_type => $color_type,
                    size       => $size_name,
                    modifiers  => dclone($variant_modifiers),
                };
                if ($size_2up) {
                    $template->{'2up'} = {
                        'size' => $size_2up,
                    };
                    $template->{'base_2up'} = $base_2up;
                }

                push(@templates, $template);
            }
        }
    }
}

# local $Data::Dumper::Indent = 1;
# print Dumper(\@templates);

sub path {
    my ($filename) = @_;
    if ($^O =~ m{^darwin}) {
        return realpath($filename);
    }
    return $filename;
}

sub cmd {
    my ($filename, $cmd) = @_;

    my $use_temp_file = 0;

    my $temp;
    if ($use_temp_file) {
        $temp = "$filename.tmp";
        if ($filename =~ m{\.([^\.\\\/]+)$}) {
            my $ext = $1;
            $temp = "$filename.tmp.$ext";
        }
    }

    my $dirname = dirname($filename);
    if (!-e $dirname) {
        if ($opt_verbose) {
            warn(sprintf("+ mkdir -p %s\n", shell_quote($dirname)));
        }
        mkpath($dirname);
    }

    $filename = path($filename);
    if ($use_temp_file) {
        $temp = path($temp);
    }

    if ($use_temp_file) {
        $cmd =~ s{\{FILENAME\}}{shell_quote($temp)}ge;
    } else {
        $cmd =~ s{\{FILENAME\}}{shell_quote($filename)}ge;
    }

    if ($opt_verbose) {
        warn("+ $cmd\n");
    }
    if (system($cmd)) {
        if (!$use_temp_file) {
            unlink($filename);
        }
        die("Command failed -- Exiting.");
    }
    if ($use_temp_file) {
        if (!-e $temp) {
            die("$temp does not exist -- Exiting.\n");
        }
        if ($opt_verbose) {
            warn(sprintf("+ mv %s %s\n", shell_quote($temp), shell_quote($filename)));
        }
        if (!rename($temp, $filename)) {
            die("Could not rename $temp to $filename: $! -- Exiting.\n");
        }
    }
}

my @modules;
find(sub {
         if (lstat($_) && -f _ && m{\.pm\z}) {
             push(@modules, $File::Find::name);
         }
     }, '.');

use constant USE_EXTERNAL_BIN_PRINTABLE => 0;

my %build = (
    svg => {
        dependencies => [qw(bin/printable makebin/makeprintable), @modules],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $id = basename($target);
            $id =~ s{(?!^)\.[^\.]+$}{}; # remove extension
            $id =~ s{[^A-Za-z0-9\_\-\.]+}{}g; # remove anything except A-Z a-z 0-9 _ - .

            my @modifiers = (eval { @{$template->{modifiers}} },
                             eval { @{$file->{modifiers}} });

            if (USE_EXTERNAL_BIN_PRINTABLE) {
                my $cmd = sprintf("bin/printable -M %s", shell_quote($template->{size}));
                $cmd .= ' --black'     if $template->{color_type} eq 'black';
                $cmd .= ' --grayscale' if $template->{color_type} eq 'grayscale';
                $cmd .= sprintf(' --id=%s', shell_quote($id));
                $cmd .= sprintf(' --filename=%s', shell_quote($target));
                foreach my $modifier (@modifiers) {
                    $cmd .= sprintf(" --modifier=%s", shell_quote($modifier));
                }
                $cmd .= sprintf(" %s >{FILENAME}", shell_quote($template->{ruling}));
                cmd($target, $cmd);
            } else {
                my $ruling_class_name = My::Printable::Ruling->getRulingClassName($template->{ruling});
                eval "use $ruling_class_name";
                if ($@) {
                    die $@;
                }
                my $ruling = $ruling_class_name->new();
                $ruling->id($id);
                $ruling->setPaperSize($template->{size});
                $ruling->colorType($template->{color_type});
                $ruling->setModifiers(@modifiers);
                $ruling->generate();
                $ruling->printToFile($target);
            }
        },
    },
    svg_pdf => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd = sprintf("inkscape --without-gui --export-dpi=300 --export-pdf {FILENAME} %s",
                              shell_quote($dependencies->[0]));

            cmd($target, $cmd);
        },
    },
    svg_ps => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd = sprintf("inkscape --without-gui --export-dpi=300 --export-ps {FILENAME} %s",
                              shell_quote($dependencies->[0]));

            cmd($target, $cmd);
        },
    },
    two_page_pdf => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd;
            if (scalar @$dependencies == 1) {
                $cmd = sprintf("pdfunite %s %s {FILENAME}",
                               shell_quote($dependencies->[0]),
                               shell_quote($dependencies->[0]));
            } else {
                $cmd = sprintf("pdfunite %s %s {FILENAME}",
                               shell_quote($dependencies->[0]),
                               shell_quote($dependencies->[1]));
            }

            cmd($target, $cmd);
        },
    },
    two_page_ps => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd;
            if (scalar @$dependencies == 1) {
                $cmd = sprintf("psselect 1,1 %s >{FILENAME}", shell_quote($dependencies->[0]));
            } else {
                $cmd = sprintf("psjoin %s %s >{FILENAME}", shell_quote($dependencies->[0]), shell_quote($dependencies->[1]));
            }

            cmd($target, $cmd);
        },
    },
    two_up_pdf => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd;

            my $input_papersizename = $template->{size};
            my ($input_width_pt, $input_height_pt) = split(/\s+/, `paperconf -s $input_papersizename`);

            my $output_papersizename = $template->{"2up"}->{size};
            my ($output_width_pt, $output_height_pt) = split(/\s+/, `paperconf -s $output_papersizename`);

            my $output_papersize = sprintf('{%.3fbp,%.3fbp}', $output_width_pt, $output_height_pt);

            my $p = $dependencies->[0];

            # Ick.  There's a Python script called pdfnup, and
            # something that comes with TeXlive called pdfnup.

            $cmd = sprintf("pdfbook --no-tidy --outfile {FILENAME} --papersize %s --nup 2x1 --twoside %s 1,2,1,2",
                           shell_quote($output_papersize),
                           shell_quote($p));

            # ick.
            # $cmd = sprintf("pdfxup -b le -im 0 -m 0 -is 0 -fw 0 -o {FILENAME} -d %s",
            #                shell_quote($p));

            cmd($target, $cmd);
        },
    },
    two_up_ps => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};
            my $p = $dependencies->[0];
            my $cmd = sprintf("pdftops %s {FILENAME}", shell_quote($p));
            cmd($target, $cmd);
        },
    },
);

sub build {
    my ($filename) = @_;
    foreach my $template (@templates) {
        foreach my $file (@{$template->{files}}) {
            if ($file->{filename} eq $filename) {
                build_file(
                    template => $template,
                    file     => $file
                );
                return;
            }
        }
    }
    die("Don't know how to build $filename.\n");
}

sub build_file {
    my %args = @_;
    my $template     = $args{template};
    my $file         = $args{file};
    my $target       = $file->{filename};
    my @dependencies = eval { @{$file->{dependencies}} };
    my $build        = $file->{build};
    my $force        = $build->{force};

    my @build_dependencies = eval { @{$build->{dependencies}} };

    if ($opt_verbose) {
        warn("$target requires:\n");
        warn("    dependencies       @dependencies\n") if scalar @dependencies;
        warn("    build dependencies @build_dependencies\n") if scalar @build_dependencies;
    }

    my $target_exists = -e $target;
    my $target_age    = -M _;

    my $make = 0;
    if ($force) {
        $make = 1;
    }
    if (!$target_exists) {
        $make = 1;
    }
    foreach my $dependency (@dependencies) {
        if (!-e $dependency) {
            build($dependency);
            $make = 1;
        } else {
            build($dependency);
            if ($target_exists && -M $dependency < $target_age) {
                $make = 1;
            }
        }
    }
    foreach my $dependency (@build_dependencies) {
        if ($target_exists && -M $dependency < $target_age) {
            $make = 1;
        }
    }

    my @path_dependencies = map { path($_) } @dependencies;

    if ($make) {
        if ($opt_verbose >= 0) {
            warn("makeprintable: Building $target ...\n");
        }
        my $code = $build->{code};
        $code->(target => $target,
                dependencies => \@path_dependencies,
                template => $template,
                file => $file,
                build => $build);
    } else {
        if ($opt_verbose >= 0) {
            warn("makeprintable: $target is up to date.\n");
        }
    }
}

foreach my $template (@templates) {
    my $ruling = $template->{ruling};
    my $base = $template->{base};

    if ($ruling eq "seyes") {
        $template->{has_even_pages} = 1;
    }

    my $svg = "templates/svg/${base}.svg";
    my $pdf = "templates/pdf/${base}.pdf";
    my $ps  = "templates/ps/${base}.ps";

    my $svg_even_page = "templates/even-page-svg/${base}.evenpage.svg";
    my $pdf_even_page = "templates/even-page-pdf/${base}.evenpage.pdf";
    my $ps_even_page  = "templates/even-page-ps/${base}.evenpage.ps";

    my $pdf_2_page = "templates/2-page-pdf/${base}.2page.pdf";
    my $ps_2_page  = "templates/2-page-ps/${base}.2page.ps";

    my $pdf_2_page_dependencies = [$pdf];
    my $ps_2_page_dependencies  = [$ps];

    $template->{files} = [];

    push(@{$template->{files}}, { type => "svg", filename => $svg,                         build => $build{svg}     });
    push(@{$template->{files}}, { type => "pdf", filename => $pdf, dependencies => [$svg], build => $build{svg_pdf} });
    push(@{$template->{files}}, { type => "ps",  filename => $ps,  dependencies => [$svg], build => $build{svg_ps}  });

    if ($template->{has_even_pages}) {
        push(@{$template->{files}}, { type => "svg", subtype => "even-page", filename => $svg_even_page,                                   build => $build{svg},    modifiers => [qw(even-page)] });
        push(@{$template->{files}}, { type => "pdf", subtype => "even-page", filename => $pdf_even_page, dependencies => [$svg_even_page], build => $build{svg_pdf} });
        push(@{$template->{files}}, { type => "ps",  subtype => "even-page", filename => $ps_even_page,  dependencies => [$svg_even_page], build => $build{svg_ps}  });

        push(@$pdf_2_page_dependencies, $pdf_even_page);
        push(@$ps_2_page_dependencies,  $ps_even_page);
    }

    push(@{$template->{files}}, { type => "pdf", subtype => "2-page", filename => $pdf_2_page, dependencies => $pdf_2_page_dependencies, build => $build{two_page_pdf} });
    push(@{$template->{files}}, { type => "ps",  subtype => "2-page", filename => $ps_2_page,  dependencies => $ps_2_page_dependencies,  build => $build{two_page_ps}  });

    my $two_up_size = eval { $template->{"2up"}->{size} };
    if ($two_up_size) {
        my $two_up_base = eval { $template->{'base_2up'} };
        my $pdf_2_up = "templates/2-up-pdf/${two_up_base}.2up.pdf";
        my $ps_2_up  = "templates/2-up-ps/${two_up_base}.2up.ps";
        push(@{$template->{files}}, { type => "pdf", subtype => "2-up", filename => $pdf_2_up, dependencies => [$pdf_2_page], build => $build{"two_up_pdf"} });
        push(@{$template->{files}}, { type => "ps",  subtype => "2-up", filename => $ps_2_up,  dependencies => [$pdf_2_up],   build => $build{"two_up_ps"} });
    }
}

my @build;
foreach my $template (@templates) {
    foreach my $file (@{$template->{files}}) {
        push(@build, { template => $template, file => $file });
    }
}

my $operation = "MAKE";

sub EQ {
    my ($a, $b) = @_;
    return 1 if defined $a && defined $b && $a eq $b;
    return 1 if !defined $a && !defined $b;
    return 0;
}

foreach my $arg (@ARGV) {
    if ($arg eq "LIST" || $arg eq "CLEAN" || $arg eq "MAKE") {
        $operation = $arg;
    } else {
        my $sub = sub {
            return 1 if EQ($_->{template}->{ruling},     $arg);
            return 1 if EQ($_->{template}->{size},       $arg);
            return 1 if EQ($_->{file}->{type},           $arg);
            return 1 if EQ($_->{file}->{filename},       $arg);
            return 1 if EQ($_->{template}->{color_type}, $arg);
            return 1 if EQ($_->{file}->{subtype},        $arg);
            my $modifiers = $_->{template}->{modifiers};
            if ($modifiers && ref $modifiers eq 'ARRAY' && scalar @$modifiers) {
                return 1 if grep { $_ eq $arg } @$modifiers;
            }
            return 0;
        };
        if ($arg =~ s{^[\!\-\^]}{}) {
            @build = grep { !$sub->() } @build;
        } else {
            @build = grep { $sub->() } @build;
        }
    }
}

if ($operation eq "LIST") {
    foreach my $build (@build) {
        my $filename = $build->{file}->{filename};
        say $filename;
    }
    exit 0;
} elsif ($operation eq "MAKE") {
    if (!scalar @build) {
        if ($opt_verbose) {
            warn("Nothing to build.\n");
        }
        exit(1);
    }
    if ($opt_verbose) {
        warn("Will build:\n");
        foreach my $build (@build) {
            my $filename = $build->{file}->{filename};
            warn("- $filename\n");
        }
    }
    foreach my $build (@build) {
        my $filename = $build->{file}->{filename};
        if ($opt_verbose) {
            warn("Building $filename...\n");
        }
        build($filename);
    }
} elsif ($operation eq "CLEAN") {
    foreach my $build (@build) {
        my $filename = $build->{file}->{filename};
        if (-e $filename) {
            warn(sprintf("+ rm %s\n", shell_quote($filename)));
            if (!unlink($filename)) {
                warn("Cannot unlink $filename: $!\n");
            }
        }
    }
}
