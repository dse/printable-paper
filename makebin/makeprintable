#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

use String::ShellQuote;
use Cwd qw(realpath);
use File::Path qw(mkpath);
use File::Basename qw(dirname basename);
use File::Find qw(find);
use Text::Trim;
use Getopt::Long;

our $opt_verbose = 0;
our $opt_dry_run = 0;

Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'v|verbose+' => \$opt_verbose,
    'n|dry-run'  => \$opt_dry_run,
    'quiet'      => sub {
        if ($opt_verbose < 0) {
            $opt_verbose -= 1;
        } else {
            $opt_verbose = -1;
        }
    },
    'h|help' => sub { usage(); exit 0; },
) or die("Type '$0 --help' for help.\n");

sub usage { print <<END; }
usage: $0 [<option> ...] [<keyword> ...]
options:
  -h, --help
  -v, --verbose
  -n, --dry-run
END

my $progname = realpath($0);
my $progdir = dirname($progname);
chdir($progdir);
my $projdir = trim(`git rev-parse --show-toplevel 2>/dev/null`);
if ($? || !defined $projdir || $projdir !~ m{\S}) {
    die("not in a git project\n");
}
chdir($projdir);

my @templates = (
    { base => "dot-grid--a4",                                ruling => "dot-grid",       size => "a4"                                                                                    },
    { base => "dot-grid--letter",                            ruling => "dot-grid",       size => "letter"                                                                                },

    { base => "line-dot-graph--a4",                          ruling => "line-dot-graph", size => "a4"                                                                                    },
    { base => "line-dot-graph--letter",                      ruling => "line-dot-graph", size => "letter"                                                                                },

    { base => "line-dot-grid--a4",                           ruling => "line-dot-grid",  size => "a4"                                                                                    },
    { base => "line-dot-grid--letter",                       ruling => "line-dot-grid",  size => "letter"                                                                                },
    { base => "line-dot-grid--thinner--a4",                  ruling => "line-dot-grid",  size => "a4",         modifiers => [qw(thinner-dots thinner-lines)]                             },
    { base => "line-dot-grid--thinner--letter",              ruling => "line-dot-grid",  size => "letter",     modifiers => [qw(thinner-dots thinner-lines)]                             },
    { base => "line-dot-grid--x-thinner--a4",                ruling => "line-dot-grid",  size => "a4",         modifiers => [qw(x-thinner-dots x-thinner-lines)]                         },
    { base => "line-dot-grid--x-thinner--letter",            ruling => "line-dot-grid",  size => "letter",     modifiers => [qw(x-thinner-dots x-thinner-lines)]                         },

    { base => "seyes--a4",                                   ruling => "seyes",          size => "a4"                                                                                    },
    { base => "seyes--letter",                               ruling => "seyes",          size => "letter"                                                                                },
    { base => "seyes--thinner-grid--a4",                     ruling => "seyes",          size => "a4",         modifiers => [qw(thinner-grid)]                                           },
    { base => "seyes--thinner-grid--letter",                 ruling => "seyes",          size => "letter",     modifiers => [qw(thinner-grid)]                                           },
    { base => "seyes--three-line--thinner-grid--letter",     ruling => "seyes",          size => "letter",     modifiers => [qw(thinner-grid three-line)]                                },
    { base => "seyes--thinner-grid--a5",                     ruling => "seyes",          size => "a5",         modifiers => [qw(thinner-grid)],            "2up" => { size => "a4" }     },
    { base => "seyes--thinner-grid--halfletter",             ruling => "seyes",          size => "halfletter", modifiers => [qw(thinner-grid)],            "2up" => { size => "letter" } },
    { base => "seyes--three-line--thinner-grid--halfletter", ruling => "seyes",          size => "halfletter", modifiers => [qw(thinner-grid three-line)], "2up" => { size => "letter" } },

    { base => "doane--letter",                               ruling => "doane",          size => "letter"                                                                                },
    { base => "doane--denser-grid--letter",                  ruling => "doane",          size => "letter",     modifiers => [qw(denser-grid)]                                            },

    { base => "quadrille--letter",                           ruling => "quadrille",      size => "letter"                                                                                },
    { base => "quadrille--5-per-inch--letter",               ruling => "quadrille",      size => "letter",     modifiers => [qw(5-per-inch)],                                            },

    { base => "seyes--thinner-wider-grid--halfletter",       ruling => "seyes",          size => "halfletter", modifiers => [qw(thinner-grid wider-grid)], "2up" => { size => "letter" } },
);

sub path {
    my ($filename) = @_;
    if ($^O =~ m{^darwin}) {
        return realpath($filename);
    }
    return $filename;
}

sub cmd {
    my ($filename, $cmd) = @_;

    my $use_temp_file = 0;

    my $temp;
    if ($use_temp_file) {
        $temp = "$filename.tmp";
        if ($filename =~ m{\.([^\.\\\/]+)$}) {
            my $ext = $1;
            $temp = "$filename.tmp.$ext";
        }
    }

    my $dirname = dirname($filename);
    if (!-e $dirname) {
        if ($opt_verbose) {
            warn(sprintf("+ mkdir -p %s\n", shell_quote($dirname)));
        }
        mkpath($dirname);
    }

    $filename = path($filename);
    if ($use_temp_file) {
        $temp = path($temp);
    }

    if ($use_temp_file) {
        $cmd =~ s{\{FILENAME\}}{shell_quote($temp)}ge;
    } else {
        $cmd =~ s{\{FILENAME\}}{shell_quote($filename)}ge;
    }

    if ($opt_verbose) {
        warn("+ $cmd\n");
    }
    if (system($cmd)) {
        if (!$use_temp_file) {
            unlink($filename);
        }
        die("Command failed -- Exiting.");
    }
    if ($use_temp_file) {
        if (!-e $temp) {
            die("$temp does not exist -- Exiting.\n");
        }
        if ($opt_verbose) {
            warn(sprintf("+ mv %s %s\n", shell_quote($temp), shell_quote($filename)));
        }
        if (!rename($temp, $filename)) {
            die("Could not rename $temp to $filename: $! -- Exiting.\n");
        }
    }
}

my @modules;
find(sub {
         if (lstat($_) && -f _ && m{\.pm\z}) {
             push(@modules, $File::Find::name);
         }
     }, '.');

my %build = (
    svg => {
        dependencies => [qw(bin/printable makebin/makeprintable), @modules],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $id = basename($target);
            $id =~ s{(?!^)\.[^\.]+$}{}; # remove extension
            $id =~ s{[^A-Za-z0-9\_\-\.]+}{}g; # remove anything except A-Z a-z 0-9 _ - .

            my $cmd = sprintf("bin/printable -M %s", shell_quote($template->{size}));
            $cmd .= sprintf(' --id=%s', shell_quote($id));
            $cmd .= sprintf(' --filename=%s', shell_quote($target));
            my @modifiers = (eval { @{$template->{modifiers}} },
                             eval { @{$file->{modifiers}} });
            foreach my $modifier (@modifiers) {
                $cmd .= sprintf(" --modifier=%s", shell_quote($modifier));
            }
            $cmd .= sprintf(" %s >{FILENAME}", shell_quote($template->{ruling}));

            cmd($target, $cmd);
        },
    },
    svg_pdf => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd = sprintf("inkscape --without-gui --export-dpi=300 --export-pdf {FILENAME} %s",
                              shell_quote($dependencies->[0]));

            cmd($target, $cmd);
        },
    },
    svg_ps => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd = sprintf("inkscape --without-gui --export-dpi=300 --export-ps {FILENAME} %s",
                              shell_quote($dependencies->[0]));

            cmd($target, $cmd);
        },
    },
    two_page_pdf => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd;
            if (scalar @$dependencies == 1) {
                $cmd = sprintf("pdfunite %s %s {FILENAME}",
                               shell_quote($dependencies->[0]),
                               shell_quote($dependencies->[0]));
            } else {
                $cmd = sprintf("pdfunite %s %s {FILENAME}",
                               shell_quote($dependencies->[0]),
                               shell_quote($dependencies->[1]));
            }

            cmd($target, $cmd);
        },
    },
    two_page_ps => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd;
            if (scalar @$dependencies == 1) {
                $cmd = sprintf("psselect 1,1 %s >{FILENAME}", shell_quote($dependencies->[0]));
            } else {
                $cmd = sprintf("psjoin %s %s >{FILENAME}", shell_quote($dependencies->[0]), shell_quote($dependencies->[1]));
            }

            cmd($target, $cmd);
        },
    },
    two_up_pdf => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};

            my $cmd;

            my $input_papersizename = $template->{size};
            my ($input_width_pt, $input_height_pt) = split(/\s+/, `paperconf -s $input_papersizename`);

            my $output_papersizename = $template->{"2up"}->{size};
            my ($output_width_pt, $output_height_pt) = split(/\s+/, `paperconf -s $output_papersizename`);

            my $output_papersize = sprintf('{%.3fbp,%.3fbp}', $output_width_pt, $output_height_pt);

            my $p = $dependencies->[0];

            # Ick.  There's a Python script called pdfnup, and
            # something that comes with TeXlive called pdfnup.

            $cmd = sprintf("pdfbook --no-tidy --outfile {FILENAME} --papersize %s --nup 2x1 --twoside %s 1,2,1,2",
                           shell_quote($output_papersize),
                           shell_quote($p));

            # ick.
            # $cmd = sprintf("pdfxup -b le -im 0 -m 0 -is 0 -fw 0 -o {FILENAME} -d %s",
            #                shell_quote($p));

            cmd($target, $cmd);
        },
    },
    two_up_ps => {
        dependencies => [qw(makebin/makeprintable)],
        code => sub {
            my %args = @_;
            my ($target, $dependencies, $template, $file, $build) = @args{qw(target dependencies template file build)};
            my $p = $dependencies->[0];
            my $cmd = sprintf("pdftops %s {FILENAME}", shell_quote($p));
            cmd($target, $cmd);
        },
    },
);

sub build {
    my ($filename) = @_;
    foreach my $template (@templates) {
        foreach my $file (@{$template->{files}}) {
            if ($file->{filename} eq $filename) {
                build_file(
                    template => $template,
                    file     => $file
                );
                return;
            }
        }
    }
    die("Don't know how to build $filename.\n");
}

sub build_file {
    my %args = @_;
    my $template     = $args{template};
    my $file         = $args{file};
    my $target       = $file->{filename};
    my @dependencies = eval { @{$file->{dependencies}} };
    my $build        = $file->{build};
    my $force        = $build->{force};

    my @build_dependencies = eval { @{$build->{dependencies}} };

    if ($opt_verbose) {
        warn("$target requires:\n");
        warn("    dependencies       @dependencies\n") if scalar @dependencies;
        warn("    build dependencies @build_dependencies\n") if scalar @build_dependencies;
    }

    my $target_exists = -e $target;
    my $target_age    = -M _;

    my $make = 0;
    if ($force) {
        $make = 1;
    }
    if (!$target_exists) {
        $make = 1;
    }
    foreach my $dependency (@dependencies) {
        if (!-e $dependency) {
            build($dependency);
            $make = 1;
        } else {
            build($dependency);
            if ($target_exists && -M $dependency < $target_age) {
                $make = 1;
            }
        }
    }
    foreach my $dependency (@build_dependencies) {
        if ($target_exists && -M $dependency < $target_age) {
            $make = 1;
        }
    }

    my @path_dependencies = map { path($_) } @dependencies;

    if ($make) {
        if ($opt_verbose >= 0) {
            warn("makeprintable: Building $target ...\n");
        }
        my $code = $build->{code};
        $code->(target => $target,
                dependencies => \@path_dependencies,
                template => $template,
                file => $file,
                build => $build);
    } else {
        if ($opt_verbose >= 0) {
            warn("makeprintable: $target is up to date.\n");
        }
    }
}

foreach my $template (@templates) {
    my $ruling = $template->{ruling};
    my $base = $template->{base};

    if ($ruling eq "seyes") {
        $template->{has_even_pages} = 1;
    }

    my $svg = "templates/svg/${base}.svg";
    my $pdf = "templates/pdf/${base}.pdf";
    my $ps  = "templates/ps/${base}.ps";

    my $svg_even_page = "templates/even-page-svg/${base}.evenpage.svg";
    my $pdf_even_page = "templates/even-page-pdf/${base}.evenpage.pdf";
    my $ps_even_page  = "templates/even-page-ps/${base}.evenpage.ps";

    my $pdf_2_page = "templates/2-page-pdf/${base}.2page.pdf";
    my $ps_2_page  = "templates/2-page-ps/${base}.2page.ps";

    my $pdf_2_page_dependencies = [$pdf];
    my $ps_2_page_dependencies  = [$ps];

    $template->{files} = [];

    push(@{$template->{files}}, { type => "svg", filename => $svg,                         build => $build{svg}     });
    push(@{$template->{files}}, { type => "pdf", filename => $pdf, dependencies => [$svg], build => $build{svg_pdf} });
    push(@{$template->{files}}, { type => "ps",  filename => $ps,  dependencies => [$svg], build => $build{svg_ps}  });

    if ($template->{has_even_pages}) {
        push(@{$template->{files}}, { type => "svg", subtype => "even-page", filename => $svg_even_page,                                   build => $build{svg},    modifiers => [qw(even-page)] });
        push(@{$template->{files}}, { type => "pdf", subtype => "even-page", filename => $pdf_even_page, dependencies => [$svg_even_page], build => $build{svg_pdf} });
        push(@{$template->{files}}, { type => "ps",  subtype => "even-page", filename => $ps_even_page,  dependencies => [$svg_even_page], build => $build{svg_ps}  });

        push(@$pdf_2_page_dependencies, $pdf_even_page);
        push(@$ps_2_page_dependencies,  $ps_even_page);
    }

    push(@{$template->{files}}, { type => "pdf", subtype => "2-page", filename => $pdf_2_page, dependencies => $pdf_2_page_dependencies, build => $build{two_page_pdf} });
    push(@{$template->{files}}, { type => "ps",  subtype => "2-page", filename => $ps_2_page,  dependencies => $ps_2_page_dependencies,  build => $build{two_page_ps}  });

    my $two_up_size = eval { $template->{"2up"}->{size} };
    if ($two_up_size) {
        my $two_up_base = eval { $template->{"2up"}->{base} } // $base . "-" . $two_up_size;
        my $pdf_2_up = "templates/2-up-pdf/${two_up_base}.2up.pdf";
        my $ps_2_up  = "templates/2-up-ps/${two_up_base}.2up.ps";
        push(@{$template->{files}}, { type => "pdf", subtype => "2-up", filename => $pdf_2_up, dependencies => [$pdf_2_page], build => $build{"two_up_pdf"} });
        push(@{$template->{files}}, { type => "ps",  subtype => "2-up", filename => $ps_2_up,  dependencies => [$pdf_2_up],   build => $build{"two_up_ps"} });
    }
}

my @build;
foreach my $template (@templates) {
    foreach my $file (@{$template->{files}}) {
        push(@build, { template => $template, file => $file });
    }
}

my $operation = "MAKE";

foreach my $arg (@ARGV) {
    if ($arg eq "LIST" || $arg eq "CLEAN" || $arg eq "MAKE") {
        $operation = $arg;
    } else {
        my $sub = sub {
            return (($_->{template}->{ruling} eq $arg) ||
                        ($_->{template}->{size} eq $arg) ||
                        ($_->{file}->{type} eq $arg) ||
                        ($_->{file}->{filename} eq $arg) ||
                        (($_->{file}->{subtype} // "") eq $arg) ||
                        grep { $_ eq $arg } @{$_->{template}->{modifiers}});
        };
        if ($arg =~ s{^[\!\-\^]}{}) {
            @build = grep { !$sub->() } @build;
        } else {
            @build = grep { $sub->() } @build;
        }
    }
}

if ($operation eq "LIST") {
    foreach my $build (@build) {
        my $filename = $build->{file}->{filename};
        say $filename;
    }
    exit 0;
} elsif ($operation eq "MAKE") {
    if (!scalar @build) {
        if ($opt_verbose) {
            warn("Nothing to build.\n");
        }
        exit(1);
    }
    if ($opt_verbose) {
        warn("Will build:\n");
        foreach my $build (@build) {
            my $filename = $build->{file}->{filename};
            warn("- $filename\n");
        }
    }
    foreach my $build (@build) {
        my $filename = $build->{file}->{filename};
        if ($opt_verbose) {
            warn("Building $filename...\n");
        }
        build($filename);
    }
} elsif ($operation eq "CLEAN") {
    foreach my $build (@build) {
        my $filename = $build->{file}->{filename};
        if (-e $filename) {
            warn(sprintf("+ rm %s\n", shell_quote($filename)));
            if (!unlink($filename)) {
                warn("Cannot unlink $filename: $!\n");
            }
        }
    }
}
